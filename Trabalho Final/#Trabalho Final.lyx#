#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\begin_preamble
\renewcommand \thefigure{Figura~\@arabic\c@figure}
\def\fps@figure{tbp}
\def\ftype@figure{1}
\def\ext@figure{lof}
\def\fnum@figure{\thefigure}
\definecolor{green}{RGB}{0, 100, 0}
\definecolor{red4}{RGB}{139, 0, 0}
\definecolor{keywords}{RGB}{0,104,139}
\definecolor{gray}{RGB}{162, 181, 205}
\definecolor{Strings}{rgb}{0,0.63,0}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language brazilian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing onehalf
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3.5cm
\topmargin 3.5cm
\rightmargin 3.5cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "aboveskip={0.5cm},basicstyle={\small\ttfamily},breaklines=true,captionpos=b,commentstyle={\itshape\color{gray}},keywords={import,from,class,def,for,while,if,is,in,elif,else,not,and,or,print,break,continue,return,access,as,,del,except,exec,finally,global,lambda,pass,print,raise,try,assert},keywordstyle={\color{keywords}\bfseries},ndkeywords={len,range, None},ndkeywordstyle={\color{red4}\bfseries},stringstyle={\color{Strings}},tab=true,tabsize=3,xleftmargin={0.5cm},xrightmargin={0.5cm}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center

\size large
FUNDAÇÃO GETÚLIO VARGAS
\end_layout

\begin_layout Standard
\align center

\size large
ESCOLA DE MATEMÁTICA APLICADA
\end_layout

\begin_layout Standard
\align center

\size large
MESTRADO 2015.1
\end_layout

\begin_layout Standard
\align center

\size large
ESTRUTURA DE DADOS E SEUS ALGORITMOS
\end_layout

\begin_layout Standard
\align center

\size large
Prof Alexandre Rademaker
\end_layout

\begin_layout Standard
\begin_inset VSpace 3cm
\end_inset


\end_layout

\begin_layout Standard
\align center

\size large
Apresentação e discussão dos exercícios selecionados
\end_layout

\begin_layout Standard
\begin_inset VSpace 3cm
\end_inset


\end_layout

\begin_layout Standard
\align center
ALUNOS:
\end_layout

\begin_layout Standard
\align center
KIZZY TERRA
\end_layout

\begin_layout Standard
\align center
OTTO TAVARES
\end_layout

\begin_layout Standard
\begin_inset VSpace 3cm
\end_inset


\end_layout

\begin_layout Standard
\align center
RIO DE JANEIRO
\end_layout

\begin_layout Standard
\align center
JUNHO DE 2015
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Introdução
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Este relatório reúne comentários e implementações dos exercícios selecionados,
 cujos enunciados foram previamente apresentados em sala de aula.
 O objetivo deste documento é, acima de tudo, apresentar as interessantes
 discussões que emergiram a medida que os exercícios foram sendo analisados
 e solucionados, ultrapassando a mera exposição da resposta final encontrada
 para cada questão escolhida.
\end_layout

\begin_layout Standard
Cabe ressaltar que alguns dos exercícios selecionados foram utilizados apenas
 como ponto de partida para discussões mais enriquecedoras a fim de proporcionar
 maior aprendizado e, possibilitando que os conhecimentos adquiridos ao
 longo do curso fossem, de fato, colocados em prática.
\end_layout

\begin_layout Section
Exercícios selecionados
\end_layout

\begin_layout Subsection
Exercício Selecionado 1
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Este exercício foi extraído do livro 
\emph on
Algorithms 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "Dasgupta2006"

\end_inset


\emph on
, 
\emph default
capítulo 6, sendo o exercício 6.1.
 O enunciado deste exercício refere-se a um conhecido problema de programação
 dinâmica: subsequência de soma máxima.
 Este problema consiste em encontrar a subsequência de números com maior
 soma dentro de uma lista unidimensional de números dada.
 
\end_layout

\begin_layout Standard
Este problema possui duas principais variações unidimensionais: na primeira,
 consideram-se apenas subsequências contíguas da lista de números; na segunda,
 por sua vez, as subsequências podem envolver números que não são contíguos.
 
\end_layout

\begin_layout Standard
O problema da subsequência contígua de soma máxima foi proposto pela primeira
 vez em 1977 por Ulf Grenander da 
\emph on
Brown University, 
\emph default
como um modelo simplificado do problema de estimativa de padrões por máxima
 verossimilhança em imagem digitalizadas.
 
\end_layout

\begin_layout Standard
O problema original do estimador de máxima verossimilhança é na verdade
 um problema de subsequência de soma máxima bidimensional, mas foi proposto
 por Grenander em sua forma simplificada (unidimensional) visto que o problema
 bidimensional exigia mais tempo para ser resolvido.
 Uma solução de tempo linear para o problema unidimensional foi encontrada
 pouco tempo depois que o problema foi proposto por Jay Kadane da 
\emph on
Carnegie-Mellon University.
 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "Bentley1984"

\end_inset


\end_layout

\begin_layout Standard

\emph on
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsubsection
A primeira versão
\end_layout

\begin_layout Subsubsection*
Problema: Subsequência contígua de soma máxima
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Entrada: Uma lista de números 
\begin_inset Formula $a_{1}$
\end_inset

, 
\begin_inset Formula $a_{2}$
\end_inset

, 
\begin_inset Formula $a_{3}$
\end_inset

, 
\begin_inset Formula $\ldots$
\end_inset

 , 
\begin_inset Formula $a_{n}$
\end_inset


\end_layout

\begin_layout Standard
Saída: A subsequência contígua de soma máxima (uma subsequência de tamanho
 zero possui soma zero)
\end_layout

\begin_layout Subsubsection*
Discussão
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A solução mais ingênua que se pode dar para esta questão consiste de um
 algoritmo força bruta que calcula todas as possíveis combinações de subsequênci
as, calcula a soma para cada uma delas e retorna a subsequência correspondente
 a maior soma encontrada.
 A seguir é apresentada a implementação desta abordagem ingênua em Python.
 
\end_layout

\begin_layout Paragraph*
Implementação
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard

\emph on
Descrição das variáveis utilizadas 
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
L: 
\emph default
lista de números (entrada)
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
sizeL: 
\emph default
tamanho da entrada L
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
max_sum: 
\emph default
armazena o valor da soma máxima.
 É inicializada com o valor do primeiro elemento da lista de números e é
 atualizada, durante a execução, a medida que são encontradas somas maiores
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
max_subsequence:
\emph default
 armazena os elementos que compõe a subsequência de soma máxima
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
current_sum: 
\emph default
armazena o valor da soma para cada iteração de 
\emph on
i
\emph default
 (laço 
\emph on
for 
\emph default
intermediário)
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout
\align left

def cubic(L):
\end_layout

\begin_layout Plain Layout

	sizeL = len(L)
\end_layout

\begin_layout Plain Layout

	if sizeL == 0:
\end_layout

\begin_layout Plain Layout

		return L
\end_layout

\begin_layout Plain Layout

	max_sum = L[0]
\end_layout

\begin_layout Plain Layout

	max_subsequence = L[:1]
\end_layout

\begin_layout Plain Layout

	for j in range(1, sizeL):
\end_layout

\begin_layout Plain Layout

		for i in range(j): 
\end_layout

\begin_layout Plain Layout

			current_sum = 0
\end_layout

\begin_layout Plain Layout

			for k in range(i,j):
\end_layout

\begin_layout Plain Layout

				current_sum += L[k]
\end_layout

\begin_layout Plain Layout

			if current_sum > max_sum:
\end_layout

\begin_layout Plain Layout

				max_sum = current_sum
\end_layout

\begin_layout Plain Layout

				max_subsequence = L[i:j]
\end_layout

\begin_layout Plain Layout

	return max_subsequence
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
O método implementado possui três laços 
\emph on
for 
\emph default
encadeados e cada um deles irá iterar no máximo N vezes, em que N é o número
 de elementos da lista de números dada como entrada, portanto a complexidade
 deste algoritmo é 
\begin_inset Formula $O(N^{3})$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Solução quadrática
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A solução cúbica apresentada é claramente ineficiente e por essa razão,
 basta pensar um pouco para identificar que podemos modificá-la facilmente
 e torná-la ligeiramente melhor, isso pode ser feito apenas eliminando o
 laço 
\emph on
for 
\emph default
mais interno, como segue:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

def quadratic(L):
\end_layout

\begin_layout Plain Layout

	sizeL = len(L)
\end_layout

\begin_layout Plain Layout

	if sizeL == 0:
\end_layout

\begin_layout Plain Layout

		return L
\end_layout

\begin_layout Plain Layout

	max_sum = L[0]
\end_layout

\begin_layout Plain Layout

	max_subsequence = L[:1]
\end_layout

\begin_layout Plain Layout

	for j in range(sizeL):
\end_layout

\begin_layout Plain Layout

		current_sum = 0
\end_layout

\begin_layout Plain Layout

		for i in range(j, sizeL):
\end_layout

\begin_layout Plain Layout

			current_sum += L[i]
\end_layout

\begin_layout Plain Layout

			if current_sum > max_sum:
\end_layout

\begin_layout Plain Layout

				max_sum = current_sum
\end_layout

\begin_layout Plain Layout

				max_subsequence = L[i:j+1]
\end_layout

\begin_layout Plain Layout

	return max_subsequence
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Esta implementação possui dois laços
\emph on
 for
\emph default
 encadeados e cada um será executado N vezes, no pior caso, logo a complexidade
 do algoritmo apresentado é 
\begin_inset Formula $O(N^{2})$
\end_inset

.
 
\end_layout

\begin_layout Standard
Embora o algoritmo quadrático seja mais eficiente do que o algoritmo cúbico,
 é possível propor soluções ainda melhores.
 A seguir será discutida uma solução linear similiar à solução proposta
 por Kadane na ocasião em que o problema foi proposto.
\end_layout

\begin_layout Subsubsection*
A solução linear
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A idéia para esta implementação é utilizar a técnica de programação dinâmica,
 isto é, construir a solução de um problema através da solução de subproblemas
 associados.
 
\end_layout

\begin_layout Standard
Neste contexto, a principal idéia é considerar que para cada elemento I
 da lista de números a solução procurada (subsequência contígua de soma
 máxima) pode ser encontrada a partir da solução calculada para o elemento
 anterior I - 1(se existir), beneficiando-se do fato de que duas somas parciais
 vizinhas computadas ao longo da execução diferem por apenas um elemento.
 
\end_layout

\begin_layout Paragraph*
Implementação
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard

\emph on
Descrição das variáveis utilizadas
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
startSoFar: 
\emph default
armazena o índice do elemento que inicia a subsequência de maior soma
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
startPrevious: 
\emph default
armazena o índice do elemento que inicia a subsequência de maior soma encontrada
 na iteração anterior
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
endSoFar:
\emph default
 armazena o índice do elemento que encerra a subsequência de maior soma
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
maxSoFar:
\emph default
 armazena o valor da subsoma máxima.
 É inicializada com o valor do primeiro elemento da lista de números e é
 atualizada, durante a execução, a medida que são encontradas somas maiores
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
maxPrevious:
\emph default
 armazena o valor da subsoma máxima encontrada na iteração anterior.
 É inicializada com o valor do primeiro elemento da lista de números e é
 atualizada, durante a execução, a medida que são encontradas somas maiores
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
O algoritmo inicia-se ao definir as variáveis, conforme descrito, e em seguida
 implementa um laço 
\emph on
for 
\emph default
para calcular a solução do problema para cada elemento I (cada iteração
 calcula a resposta para o problema como se a lista de números terminasse
 no elemento I), para isso verifica-se qual subsequência possui maior soma:
 a subsequência composta por todos os elementos até I (
\begin_inset Formula $S[I-1]\cup L[I]$
\end_inset

 ) ou a subsequência que se inicia em I(
\begin_inset Formula $S[I]=\{L[I]\}$
\end_inset

).
 
\end_layout

\begin_layout Standard
Uma vez encontrada a melhor solução para a iteração as variáveis auxiliares
 são devidamente atualizadas: caso a subsoma encotrada ao final de uma determina
da iteração (
\emph on
maxPrevious
\emph default
) seja maior que a subsoma máxima encontrada em todas as iterações anteriores
 (
\emph on
maxSoFar
\emph default
), dai as variáveis 
\emph on
maxSoFar
\emph default
, 
\emph on
startSoFar
\emph default
 e 
\emph on
endSoFar
\emph default
 são modificadas.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

if maxPrevious + L[i] >= L[i]:             
\end_layout

\begin_layout Plain Layout

	maxPrevious = maxPrevious + L[i]         
\end_layout

\begin_layout Plain Layout

else:            
\end_layout

\begin_layout Plain Layout

	startPrevious = i             
\end_layout

\begin_layout Plain Layout

	maxPrevious = L[i]         
\end_layout

\begin_layout Plain Layout

if maxPrevious >= maxSoFar:             
\end_layout

\begin_layout Plain Layout

	maxSoFar = maxPrevious             
\end_layout

\begin_layout Plain Layout

	endSoFar = i             
\end_layout

\begin_layout Plain Layout

	startSoFar = startPrevious     
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ao final de todas as iterações a subsequência de soma máxima é retornada.
 O método completo é apresentado a seguir:
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

def linear(L):
\end_layout

\begin_layout Plain Layout

	startSoFar = 0     
\end_layout

\begin_layout Plain Layout

	startPrevious = 0     
\end_layout

\begin_layout Plain Layout

	endSoFar = 0     
\end_layout

\begin_layout Plain Layout

	maxSoFar = L[0]     
\end_layout

\begin_layout Plain Layout

	maxPrevious = L[0] 
\end_layout

\begin_layout Plain Layout

	for i in range(1,len(L)):         
\end_layout

\begin_layout Plain Layout

		if maxPrevious + L[i] >= L[i]:             
\end_layout

\begin_layout Plain Layout

			maxPrevious = maxPrevious + L[i]         
\end_layout

\begin_layout Plain Layout

		else:            
\end_layout

\begin_layout Plain Layout

			startPrevious = i             
\end_layout

\begin_layout Plain Layout

			maxPrevious = L[i]         
\end_layout

\begin_layout Plain Layout

		if maxPrevious >= maxSoFar:             
\end_layout

\begin_layout Plain Layout

			maxSoFar = maxPrevious             
\end_layout

\begin_layout Plain Layout

			endSoFar = i             
\end_layout

\begin_layout Plain Layout

			startSoFar = startPrevious 
\end_layout

\begin_layout Plain Layout

	return L[startSoFar:endSoFar+1]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
No método apresentado, o laço 
\emph on
for 
\emph default
é o único bloco da implementação que depende do tamanho da entrada e este
 laço será executado N vezes, e, para cada iteração, irá executar um número
 constante de operações O(1).
 Portanto, a complexidade desta solução é 
\begin_inset Formula $O(N)$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
A segunda versão
\end_layout

\begin_layout Subsubsection*
Problema: Subsequência de soma máxima
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Entrada: Uma lista de números 
\begin_inset Formula $a_{1}$
\end_inset

, 
\begin_inset Formula $a_{2}$
\end_inset

, 
\begin_inset Formula $a_{3}$
\end_inset

, 
\begin_inset Formula $\ldots$
\end_inset

 , 
\begin_inset Formula $a_{n}$
\end_inset


\end_layout

\begin_layout Standard
Saída: A subsequência (não necessariamente contígua) de maior soma
\end_layout

\begin_layout Subsubsection*
Discussão
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para esta versão do problema, a qual os números que compõe a sequência a
 ser retornada podem ser não-adjacentes, as soluções apresentadas na seção
 anterior não podem ser utilizadas, visto que em tais implementações, memorizava
-se a solução parcial encontrada a cada iteração para que fosse utilizada
 no cálculo da solução parcial da iteração seguinte.
 
\end_layout

\begin_layout Standard
Entretanto, para que se possa encontrar a solução correta para este caso,
 é necessário calcular a solução parcial em uma determinada iteração em
 relação a todas as iterações anteriores, e não apenas em relação a solução
 parcial imediatamente anteiror como fazia-se na seção 2.1.1.
 A seguir será apresentada uma solução com complexidade de tempo quadrática
 no tamanho da entrada.
\end_layout

\begin_layout Subsubsection*
Uma solução quadrática
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Esta implementação utiliza a técnica de programação dinâmica através do
 armazenamento de resultados intermediários calculados ao longo da execução.
 A idéia deste algoritmo consiste em calcular a solução para uma determinada
 iteração levando-se em consideração todos os resultados previamente calculados
 de modo que a subsequência de soma máxima encontrada para a iteração será:
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\noindent

\size footnotesize
\begin_inset Formula 
\[
subseqMax(i)=max\{max\{subseqMax(k)\cup elemento(i);\,k<i\},\;elemento(i)\}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Isto é, a subsequência de soma máxima para uma dada iteração I é calculada
 comparando as somas das subsequências encontradas nas iterações anteriores
 adicionadas do elemento I, com o próprio elemento I.
\end_layout

\begin_layout Standard
Estas comparações executadas a cada iteração tornam esta solução quadrática,
 uma vez que o número de comparações por iteração é (I-1) e são realizadas
 N iterações no total, onde N é o tamanho da entrada, logo a complexidade
 de tempo do algoritmo é 
\begin_inset Formula $O(N^{2})$
\end_inset

.
 Nesta solução, a complexidade de espaço também depende do tamanho da entrada,
 uma vez que são armazenados os resultados intermediários obtidos para as
 N iterações, tornando a complexidade espacial 
\begin_inset Formula $O(N)$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Paragraph*
Implementação
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard

\emph on
Descrição das variáveis utilizadas 
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
L : 
\emph default
lista de números
\emph on
 
\emph default
(entrada)
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
sizeL : 
\emph default
tamanho da entrada
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
maxSoFar_index: 
\emph default
armazena o índice do último elemento da subsequência de soma máxima.
 É inicializado com zero, sendo atualizado a medida que subsequências com
 somas maiores são encontradas
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
maxSum: 
\emph default
array de tamanho N que armazena em cada posição 
\emph on
k
\emph default
 o valor da soma da subsquência de soma máxima encontrada para a posição
 
\emph on
k.
 
\emph default
É inicializado com os elementos da entrada L
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
subsequence: 
\emph default
array de tamanho N utlilizado para recuperar os elementos que compõe a subsequên
cia de soma máxima.
 Cada posição corresponde a um elemento 
\emph on
i 
\emph default
e armazena o índice do elemento que o antecede na subsequência de soma máxima.
 Os elementos deste array são inicializados com valor -1.
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
max_subsequence: 
\emph default
armazena os elementos que compõe a subsequência de soma máxima
\end_layout

\begin_layout Standard
A algortimo inicia-se com ao definir as variáveis, conforme descrito, e
 em seguida implementa dois laços 
\emph on
for
\emph default
 encadeados para encontrar os resultados intermediários para cada um dos
 elementos da lista, segundo a equação apresentada acima.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	for i in range(1,sizeL):    
\end_layout

\begin_layout Plain Layout

		for j in range(i):                            
\end_layout

\begin_layout Plain Layout

			if maxSum[j] + L[i] >= maxSum[i]:                                
\end_layout

\begin_layout Plain Layout

				subsequence[i] = j                                
\end_layout

\begin_layout Plain Layout

				maxSum[i] = maxSum[j] + L[i]                                 
\end_layout

\begin_layout Plain Layout

		if maxSum[i] >= maxSum[maxSoFar_index]:                     
\end_layout

\begin_layout Plain Layout

			maxSoFar_index = i 
\end_layout

\begin_layout Plain Layout

          
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ao final de todas as iterações recupera-se a subsequência de soma máxima
 utilizando-se o array 
\emph on
subsequence
\emph default
 e é armazenada no array 
\emph on
max_subsequence 
\emph default
para ser retornada.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

k = maxSoFar_index
\end_layout

\begin_layout Plain Layout

while k != -1 :            
\end_layout

\begin_layout Plain Layout

	max_subsequence.append(L[k])            
\end_layout

\begin_layout Plain Layout

	k = subsequence[k]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
O método completo é apresentado a seguir:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

def quadratic(L):
\end_layout

\begin_layout Plain Layout

	sizeL = len(L)
\end_layout

\begin_layout Plain Layout

	if sizeL < 1:
\end_layout

\begin_layout Plain Layout

		return L
\end_layout

\begin_layout Plain Layout

	maxSoFar_index = 0
\end_layout

\begin_layout Plain Layout

	maxSum = []
\end_layout

\begin_layout Plain Layout

	subsequence = []
\end_layout

\begin_layout Plain Layout

	for i in range(sizeL):         
\end_layout

\begin_layout Plain Layout

		maxSum.append(L[i]) 
\end_layout

\begin_layout Plain Layout

	for i in range(sizeL):          
\end_layout

\begin_layout Plain Layout

		subsequence.append(-1) 
\end_layout

\begin_layout Plain Layout

	for i in range(1,sizeL):    
\end_layout

\begin_layout Plain Layout

		for j in range(i):                            
\end_layout

\begin_layout Plain Layout

			if maxSum[j] + L[i] >= maxSum[i]:                                
\end_layout

\begin_layout Plain Layout

				subsequence[i] = j                                
\end_layout

\begin_layout Plain Layout

				maxSum[i] = maxSum[j] + L[i]                                 
\end_layout

\begin_layout Plain Layout

		if maxSum[i] >= maxSum[maxSoFar_index]:                     
\end_layout

\begin_layout Plain Layout

			maxSoFar_index = i     
\end_layout

\begin_layout Plain Layout

	k = maxSoFar_index
\end_layout

\begin_layout Plain Layout

	max_subsequence=[]
\end_layout

\begin_layout Plain Layout

	while k != -1 :            
\end_layout

\begin_layout Plain Layout

		max_subsequence.append(L[k])            
\end_layout

\begin_layout Plain Layout

		k = subsequence[k]
\end_layout

\begin_layout Plain Layout

    max_subsequence.reverse()            
\end_layout

\begin_layout Plain Layout

	return max_subsequence
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Análise dos tempos de execução
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nesta seção, apresentamos uma comparação dos tempos de execução obtidos
 para as diferentes implementações apresentadas até aqui, considerando diferente
s tamanhos de entrada:
\end_layout

\begin_layout Subsubsection*
Subsequências Contíguas
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="4">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tamanho da entrada
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Algoritmo cúbico
\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="left" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Algoritmo Quadrático
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Algoritmo linear
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(N^{3})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(N^{2})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(N)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{0}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Tempos de execução
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Subsequências Não-Contíguas
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tamanho da entrada
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Algoritmo Quadrático
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(N^{2})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{0}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Tempos de execução
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Exercício Selecionado 2
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
O Exercício a seguir foi extraído do livro 
\emph on
Algorithm Design 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "Kleinberg2005"

\end_inset

, capitulo 4, que aborda o tema de algoritmos gulosos, sendo o exercício
 de número 7.
 Sua escolha foi pautada pelo interesse em enunciar e provar a eficiência
 de um algoritmo guloso.
\end_layout

\begin_layout Standard
Dado um problema, um algoritmo guloso tem como principal característica
 construir uma solução em pequenos passos, de modo a escolher uma ação a
 cada passo sob um determinado critério, com o objetivo de otimizar a solução
 final.
 Dessa forma, ao final da rotina (gulosa), deve-se retornar como saída uma
 solução ótima.
 É possível identificar diferentes critérios para resolução de um problema,
 por intermédio de um algoritmo guloso, porém, não necessariamente, o critério
 escolhido nos leva à solução ótima.
 Por essa razão, após construir um algoritmo guloso, se faz necessário provar
 que a solução proposta por tal algoritmo é ótima, sendo esse o nosso objetivo
 com esse exercício.
\end_layout

\begin_layout Subsubsection
Enunciado
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Existe um conjunto de N trabalhos diferentes 
\begin_inset Formula $J_{1},J_{2},...,J_{n}$
\end_inset

 que devem ser executados por N PCs.
 Porém, antes de poder ser executado em algum dos PCs, os trabalhos devem
 ser pré-processados em um único supercomputador, o qual só pode pré-processar
 um trabalho de cada vez.
 Cada um dos trabalhos 
\begin_inset Formula $J_{i}$
\end_inset

 leva um tempo 
\begin_inset Formula $P_{i}$
\end_inset

 para ser finalizado pelo supercomputador.
 Após este tempo 
\begin_inset Formula $P_{i}$
\end_inset

, cada job 
\begin_inset Formula $J_{i}$
\end_inset

 é encaminhado para um PC, o qual leva um tempo 
\begin_inset Formula $f_{i}$
\end_inset

 para finalizar o trabalho.
\end_layout

\begin_layout Standard
Pergunta-se: Qual a melhor forma de alocar os trabalhos dos supercomputadores
 e dos PCs de modo a minimizar o tempo total necessário pra finalizar o
 proceassamentos de todos os trabalhos?
\end_layout

\begin_layout Subsubsection
Prova da Otimalidade
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A primeira etapa será analisar os jobs do supercomputador.
 Como já dito no enunciado, 
\begin_inset Formula $P_{i}$
\end_inset

 será o valor da duração dos jobs do supercomputador e 
\begin_inset Formula $F_{i}$
\end_inset

 o valor duração dos jobs dos PCs.
\end_layout

\begin_layout Standard
Uma vez que todos os jobs de um PC iniciam necessariamente após o job de
 um supercomputador, e como os jobs do supercomputador devem ser ordenados
 de modo que nao haja sobreposição entre seus valores, podemos inferir que
 a ordem dos jobs do supercomputador é indiferente, pois dadas as hipóteses
 listadas, o que de fato irá interferir na otimalidade da soma dos tempos
 dos jobs em questão, será a ordem dos trabalhos dos PCs.
\end_layout

\begin_layout Standard
Com efeito, nosso algoritmo A, exposto em código python na próxima seção,
 ordena a duração dos jobs feitos pelos PCs em ordem decrescente.
 Em resumo, nosso critério será escolher a cada passo o job de um PC de
 maior valor.
 Através desse algoritmo, vamos ser capazes de alocar os jobs dos supercomputado
res e dos PCs de modo a gastar o menor tempo possível nessa tarefa, como
 será provado a seguir:
\end_layout

\begin_layout Standard

\emph on
Passo Base: Seja k a iteração no tempo, temos nesse passo k = 1.
\end_layout

\begin_layout Standard

\emph on
Seja 
\emph default

\begin_inset Formula $F_{i}^{*}$
\end_inset


\emph on
 o job de maior duração feito por um PC, supõe-se um algoritmo O que não
 posiciona o job 
\emph default

\begin_inset Formula $F_{i}^{*}$
\end_inset


\emph on
 na primeira posição, isto é, após o termino do job do primeiro supercomputador.
 Isso nos leva à conclusão de que o algoritmo O não ordena os trabalhos
 dos PCs em ordem decrescente dos valores de duração.
 Aqui, destaca-se o fato de que para um job de um PC começar o de um supercomput
ador deve terminar e, no passo base, apenas um job 
\begin_inset Formula $P_{1}$
\end_inset

 foi concluído por um supercomputador.
 Seja T o tempo gasto pelo algoritmo A implementado nesse artigo e seja
 T` o tempo gasto pelo algoritmo O, pode-se afirmar que:
\end_layout

\begin_layout Standard

\emph on
\begin_inset Formula 
\[
T=P_{1}+F_{i}^{*}<P_{-1}+F_{i}^{*}=T^{'}
\]

\end_inset

 
\end_layout

\begin_layout Standard

\emph on
Ao considerar 
\begin_inset Formula $P_{-1}$
\end_inset

como P não um, sabemos que tal job começará necessariamente após 
\begin_inset Formula $P_{1}$
\end_inset

.
 Ou seja, se 
\emph default

\begin_inset Formula $F_{i}^{*}$
\end_inset


\emph on
 for posicionado em outro lugar que não com 
\begin_inset Formula $P_{1}$
\end_inset

 por O, o algoritmo A termina em menor tempo.
 Por outro lado, se 
\emph default

\begin_inset Formula $F_{i}^{*}$
\end_inset

 é
\emph on
 posicionado com 
\begin_inset Formula $P_{1}$
\end_inset

 por O, como em A, temos que os dois fazem a mesma escolha ótima T.
 Assim o algoritmo A mantém a propriedade de "stays ahead"
\begin_inset Foot
status open

\begin_layout Plain Layout
Método de demonstração, o qual compara-se as soluções parciais que o algoritmo
 guloso constrói com as soluções parciais propostas por um algoritmo suposto
 ótimo.
 O objetivo é mostrar que o algoritmo guloso possui soluções iguais ou melhores,
 do ponto de vista de otimalidade, frente ao algoritmo suposto ótimo.
\end_layout

\end_inset

 de algoritmos gulosos.
\end_layout

\begin_layout Standard

\emph on
Passo Indutivo: Aqui, considera-se que as iterações k =< n são válidas.
\end_layout

\begin_layout Standard

\emph on
A partir da hipótese indutiva podemos dizer que:
\end_layout

\begin_layout Standard

\emph on
\begin_inset Formula 
\[
T=P_{k+1}+F_{i-k}^{*}<P_{k+j}+F_{i-k}^{*}=T^{'},\;sendo\;j\geq1
\]

\end_inset


\end_layout

\begin_layout Standard

\emph on
Considera-se 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $F_{i-k}^{*}$
\end_inset


\family default
\series default
\shape default
\size default
\emph on
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang brazilian
 como o job de maior duração na iteração k.
 Esta desigualdade é válida pois 
\begin_inset Formula $P_{n+j}$
\end_inset

 necessariamente começa após 
\begin_inset Formula $P_{n+1}$
\end_inset

 o que faz do tempo em O ser maior do que em A.
 Se j = 1, então o algoritmo O possui tempo igual ao tempo de A, o que garante
 novamente a propriedade de 
\begin_inset Quotes eld
\end_inset

stays ahead
\begin_inset Quotes erd
\end_inset

.
 Dessa forma, pode-se concluir que nosso algoritmo é ótimo.
\end_layout

\begin_layout Subsubsection
Implementação
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A entrada do problema é uma lista de jobs representados por tuplas
\begin_inset Foot
status open

\begin_layout Plain Layout
Uma tupla é uma estrutura de dados finitos e ordenados.
 Uma propriedade paritucular da tupla está no fato de ser imutável, o que
 se mostra útil para análise do presente artigo.
\end_layout

\end_inset

 do tipo 
\begin_inset Formula $(p_{i},f_{i})$
\end_inset

 em que o primeiro elemento é o tempo que o supercomputador leva para processar
 o job e o segundo é o tempo de execução que PC escolhido leva para análise
 de tais dados.
\end_layout

\begin_layout Standard
Já a saída é uma lista de jobs -representados por tuplas do tipo 
\begin_inset Formula $(p_{i},f_{i})$
\end_inset

- na ordem ótima em que devem ser executados para minimizar o tempo total
 de execução.
 Isto posto, vamos analisar as funções criadas para resolução do problema.
\end_layout

\begin_layout Standard
É importante destacar que estamos implementando um algoritmo guloso, que
 já teve sua otimalidade demonstrada na seção anterior.
 Após a prova de otimalidade do algoritmo, a implementação consiste em uma
 variação do mergesort, pois estamos interessados na ordem descrescente
 de elementos que serão expostos na lista de tuplas.
 
\end_layout

\begin_layout Standard
Para tornar mais claro o argumento, vamos expor um exemplo de como será
 o dado de input.
 A lista a seguir expõe tuplas com os valores de tempo tomado pelo supercomputad
or para processamento dos dados na primeira casa, enquanto a segunda casa
 leva o tempo tomado pelos PCs para análise dos dados em questão.
 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

lista = [(24,5),(31,9),(57,22),(39,56),(5,1),(82,43)]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A primeira função analisada corresponde àquela responsável por comparar
 duas tuplas no caso base e é denominada de 
\emph on
compare
\emph default
.
 Ela toma os valores dos tempos do PC (i.e.
 segunda casa) como parâmetro.
 Essa função tem custo de complexidade O(1).
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def compare(a, b):     
\end_layout

\begin_layout Plain Layout

	return a[1] >= b[1] 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A segunda função analisada é a 
\emph on
merge
\emph default
 modificada.
 A função 
\emph on
merge
\emph default
, revisitada pelo problema, expõe como caso passo base o controle de quando
 umas das listas possui tamanho nulo, retornando a outra lista de input.
 Até aqui a estrutura do algoritmo é semelhante ao de um 
\emph on
merge
\emph default
 tradicional.
 Porém, a partir do caso base, o nossa função de comparação faz o argumento
 recursivo retornar os elementos em ordem inversa, o que nos proporciona
 ordenar os jobs dos PCs em ordem decrescente, como segue: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def merge(lista_rst, lista_nd):     
\end_layout

\begin_layout Plain Layout

	if len(lista_rst) is 0:         
\end_layout

\begin_layout Plain Layout

		return(lista_nd)     
\end_layout

\begin_layout Plain Layout

	elif len(lista_nd) is 0:         
\end_layout

\begin_layout Plain Layout

		return(lista_rst)     
\end_layout

\begin_layout Plain Layout

	else:         
\end_layout

\begin_layout Plain Layout

	#Modificacao para iterar entre tuplas e ordenar em ordem decrescente dos
 valores dos jobs dos PCs         
\end_layout

\begin_layout Plain Layout

		if compare(lista_rst[0], lista_nd[0]):             
\end_layout

\begin_layout Plain Layout

			temp = [lista_rst[0]]
\end_layout

\begin_layout Plain Layout

			temp.extend(merge(lista_rst[1:],lista_nd))             
\end_layout

\begin_layout Plain Layout

			return(temp)         
\end_layout

\begin_layout Plain Layout

		else:             
\end_layout

\begin_layout Plain Layout

			temp = [lista_nd[0]]             
\end_layout

\begin_layout Plain Layout

			temp.extend(merge(lista_rst,lista_nd[1:]))             
\end_layout

\begin_layout Plain Layout

			return(temp)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Por fim, a função 
\emph on
mergesort_inverse
\emph default
 é responsável por receber a lista exposta acima e chamar a função 
\emph on
merge
\emph default
 aplicada ao 
\emph on
mergesort_inverse 
\emph default
da metade das listas.
 Esse argumento possui complexidade da ordem de O(nlogn) e retorna os tempos
 dos jobs dos PCs em ordem decrescente.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def mergesort_inverse(lista):     
\end_layout

\begin_layout Plain Layout

	if len(lista) <= 1:         
\end_layout

\begin_layout Plain Layout

		return(lista)     
\end_layout

\begin_layout Plain Layout

	else:         
\end_layout

\begin_layout Plain Layout

		med = len(lista) // 2         
\end_layout

\begin_layout Plain Layout

		result=merge(mergesort_inverse(lista[:med]),mergesort_inverse(lista[med:]))
        
\end_layout

\begin_layout Plain Layout

		return(result)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Conclusão
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Destaca-se que esse problema teve sua escolha aclamada por abordar conceitos
 de Algoritmos Gulosos e de Divisão e Conquista, sendo a prova de otimalidade
 fundamentada pelo primeiro e a implementação pelo segundo.
 Dado que devemos minimizar o tempo dos jobs dos computadores, possuímos
 uma função objetivo que deve ser minimizada e, para isso, utilizamos os
 conceitos de algoritmos gulosos, de modo a escolher um critério, que será
 utilizado por passo, minimizando o tempo de processamento em questão.
 
\end_layout

\begin_layout Standard
Ao concluir a prova de otimalidade, é fácil ver que a implementação se resume
 ao ordenamento dos dados de input, o que nos leva à luz da implementação
 de um Mergesort modificado de custo O(nlogn) de complexidade.
 
\end_layout

\begin_layout Subsection
Exercício Selecionado 3
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Esse exercício foi extraído do livro 
\emph on
Algorithm Design
\emph default
 de 
\emph on
John Kleinberg
\emph default
 e de 
\emph on
Eva Tardos, 
\emph default
capítulo 5, sendo o exercício de número 3 o selecionado.
\end_layout

\begin_layout Subsubsection
Enunciado
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Supõe-se que esteja fazendo uma consultoria a um banco, que está preocupado
 em detectar possíveis fraudes, e esse banco surge com o seguinte problema:
\end_layout

\begin_layout Standard
O banco possui uma coleção de N cartões, os quais foram confiscados, pois
 o banco suspeita que tais cartões estejam sendo usados em uma fraude.
 Cada cartão de crédito é um pequeno pedaço de plástico, contendo uma tira
 magnética com um dado criptografado.
 Cada conta pode possuir uma série de cartões de crédito, e vamos dizer
 que dois cartões são equivalentes se eles correspondem à mesma conta.
 É muito difícil ler o número criptografado, mas o banco possui uma tecnologia
 que faz o seguinte teste:
\end_layout

\begin_layout Standard
Toma dois cartões, faz algumas contas e determina se os cartões são equivalentes.
\end_layout

\begin_layout Standard
Isto posto, a pergunta é a seguinte: Entre a coleção de N cartões, existe
 um conjunto maior que N/2 cartões que acusarão equivalência no teste? Considera
-se a hipótese de a única operação possível que se possa fazer para testar
 os cartões seja pegar dois deles, plugar na máquina, e daí verificar a
 equivalência.
 
\end_layout

\begin_layout Standard
Nossa abordagem no presente artigo será a de resolução do exercício proposto
 pelo livro, para posteriormente aplicarmos essa resolução a um problema
 real, evolvendo um dataset com dados de educação superior no Brasil.
\end_layout

\begin_layout Subsubsection
Abordagem Linear
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Inspirado em um problema real, buscamos resolver o problema exposto no enunciado
 através de uma solução linear, tomando algumas hipóteses simplicaficadoras
 para facilitar a análise.
 O primeiro passo consiste na estruturação do dado de forma conveninente,
 para que a partir do dado estruturado sejamos capazes de capturar os valores
 que apresentam igualdade com custo de complexidade linear.
 
\end_layout

\begin_layout Standard
Após a estruturação do dado vamos explicar como se deu a construção das
 funções responsáveis por comparação dos dados, contagem dos casos com igualdade
, e da função mestre, responsável por chamar todas as demais e verificar
 sob determinado parâmetro se há fraude.
 Destaca-se que nossa solução usará o zero como parâmetro ao invés de metade
 da lista, pois somos capazes de retornar o número exato de fraudes.
 
\end_layout

\begin_layout Standard
Assim caso esse número seja diferente de zero, a função retorna um valor
 lógico 
\emph on
True, 
\emph default
além de retornar 
\emph on
False
\emph default
 caso contrário.
 A pertinência do input parâmetro consiste na extensão do algoritmo para
 casos mais gerais comparados ao exercício em questão.
 Para resolver o exercício proposto basta-se truncar o parâmetro no valor
 zero e estar atento apenas ao valor lógico de output.
 No entanto, em outras aplicações, pode ser pertinente tolerar um certo
 nível maior do que zero de 
\begin_inset Quotes eld
\end_inset

fraudes
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Implementação
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Com efeito, o algoritmo leva em consideração algumas hipóteses simplificadoras.
 Para que seja linear e retorne o valor desejado, os dados, aqui representando
 códigos de cartões de crédito, quando iguais, e em número par, devem estar
 justapostos em pares, não importando a posição de tais pares.
 Caso haja um número ímpar de determinado código, deve-se justapor o número
 par máximo de códigos em pares e o valor restante deve ser justaposto com
 outro valor que tenha sobrado de uma situação semelhante, isto é, de um
 conjunto de códigos iguais ímpares.
 Caso não haja esse outro valor, deve-se justapor o valor que tenha sobrado
 com a variável nula.
\end_layout

\begin_layout Standard
A seguir se expõe como é feita a construção da lista, atendendo às condições
 descritas acima.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

lst = [1201,1201,1308,1308,1201,1403,1308] 
\end_layout

\begin_layout Plain Layout

lst_pares = []
\end_layout

\begin_layout Plain Layout

pare = len(lst) + 1 
\end_layout

\begin_layout Plain Layout

teste_impar = len(lst) % 2 != 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if teste_impar:     
\end_layout

\begin_layout Plain Layout

	pare = len(lst) 
\end_layout

\begin_layout Plain Layout

	cont = 1 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

while cont != pare:     
\end_layout

\begin_layout Plain Layout

	lst_pares.append((lst[cont - 1],lst[cont]))     
\end_layout

\begin_layout Plain Layout

	cont += 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if teste_impar:     
\end_layout

\begin_layout Plain Layout

	lst_pares.append((lst[len(lst) - 1], None)) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A lista construída para o exemplo ilustrado acima tem o seguinte formato:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[(1201, 1201), (1308, 1308), (1201, 1403), (1308,None)]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Após a construção da lista, vamos mostrar como se deu a construção da função
 responsável por comparar os valores dos códigos analisados.
 A função 
\emph on
compara, 
\emph default
quando chamada, toma dois valores e verifica sua igualdade.
 Caso haja igualdade ela retorna o valor lógico 
\emph on
True
\emph default
 e retorna 
\emph on
False 
\emph default
caso contrário.
 Essa função possui custo de complexidade da ordem O(1).
 Segue o código:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def compara(valor1, valor2):     
\end_layout

\begin_layout Plain Layout

	if valor1 == valor2:         
\end_layout

\begin_layout Plain Layout

		return(True)     
\end_layout

\begin_layout Plain Layout

	else:         
\end_layout

\begin_layout Plain Layout

		return(False)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Além da função compara, se faz necessário definir outras duas funções de
 teste.
 A primeira seria a função 
\emph on
testa_igual 
\emph default
e a segunda seria a 
\emph on
testa_dif.
 
\emph default
A construção dessas funções se mostrou necessária, pois dado que possuímos
 uma lista de tuplas, temos interesse em criar uma lista com tuplas que
 representem apenas pares iguais, ou que tenham um par entre um código de
 um cartão e um valor nulo e, outra lista, que apresente apenas pares com
 valores diferentes entre si.
 Dai, de posse dessas funções, basta utilizarmos o argumento linear filter,
 que será explicado com mais calma a seguir, para que sejamos capazes de
 criar as listas citadas.
 É importante destacar que ambas as funções possuem custo de complexidade
 O(1).
 Seguem-nas:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def testa_igual(lista):     
\end_layout

\begin_layout Plain Layout

	if lista[0] == lista[1]:         
\end_layout

\begin_layout Plain Layout

		return(lista[0])     
\end_layout

\begin_layout Plain Layout

	elif lista[0] is None:         
\end_layout

\begin_layout Plain Layout

		return(lista[1])     
\end_layout

\begin_layout Plain Layout

	elif lista[1] is None:         
\end_layout

\begin_layout Plain Layout

		return(lista[0])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def testa_dif(lista):     
\end_layout

\begin_layout Plain Layout

	if lista[0] != lista[1]:         
\end_layout

\begin_layout Plain Layout

		return((lista[0],lista[1]))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nesse passo, vamos descrever a construção da função de maior importância
 da implementação em questão, a função 
\emph on
contagem
\emph default
.
 Será por intermédio dessa função que seremos capazes de contar os códigos
 que extrapolam o número permitido de igualdades, e assim, retornarmos o
 número de fraudes.
 
\end_layout

\begin_layout Standard
Dado que o input são as listas, já citadas, dos pares de valores iguais
 (restante) e a dos pares de valores distindos (deletado),
\begin_inset Foot
status open

\begin_layout Plain Layout
O nome restante se dá pelo fato de o argumento funcional que constrói tal
 lista, retornar apenas os valores restantes que atendem ao critério de
 igualdade seus valores, critério esse definido através da construção da
 função 
\emph on
testa_igual.

\emph default
 Enquanto o nome deletado recorre justamente do fato de que esses são os
 valores que não estão justpostos em igualdade sendo deletados da primeira
 lista.
\end_layout

\end_inset

o primeiro passo da função 
\emph on
contagem
\emph default
 decorre de tomar tais listas e desconstruí-las de modo a criar duas novas
 listas com os valores dos casos em que já se tem pares definidos (restante_list
a) ou um valor que tenha sobrado, para o caso de a lista ter tamanho ímpar,
 e a outra lista ser justamente os valores que não estavam justapostas aos
 seus pares (deletado_lista).
 
\end_layout

\begin_layout Standard
A partir daí, toma-se cada valor da primeira lista citada(restante_lista)
 e busca-se na segunda lista citada (deletado_lista) por repetições.
 Caso uma repetição seja encontrada, conta-se uma fraude e deleta-se o valor
 encontrado da lista de busca (i.e.
 deletado_lista).
 Dessa forma, no primeiro passo tem-se complexidade O(n/2), no segundo O(n/4),
 e assim por diante, além de O(n-1) para realização dos testes, dando um
 total de no máximo O(2n) de complexidade, pro pior caso de se percorrer
 toda a lista duas vezes.
 Segue o código:
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def contagem(restante, deletado):     
\end_layout

\begin_layout Plain Layout

	repeticoes = 0     
\end_layout

\begin_layout Plain Layout

	restante_lista = []     
\end_layout

\begin_layout Plain Layout

	deletado_lista = []     
\end_layout

\begin_layout Plain Layout

	#necessario transformas as listas que estavam em tuplas em apenas listas,
 para manter linearidade.
     
\end_layout

\begin_layout Plain Layout

	for valor_tupla in restante:         
\end_layout

\begin_layout Plain Layout

		restante_lista.append(valor_tupla[0])     
\end_layout

\begin_layout Plain Layout

	for valor_tupla in deletado:         
\end_layout

\begin_layout Plain Layout

		deletado_lista.extend([valor_tupla[0],valor_tupla[1]])     
\end_layout

\begin_layout Plain Layout

	for valor in restante_lista:         
\end_layout

\begin_layout Plain Layout

		cont = 0         
\end_layout

\begin_layout Plain Layout

		if valor is None:             
\end_layout

\begin_layout Plain Layout

			next         
\end_layout

\begin_layout Plain Layout

		while cont != len(deletado_lista):             
\end_layout

\begin_layout Plain Layout

			if compara(valor,deletado_lista[cont]) is True:                 
\end_layout

\begin_layout Plain Layout

			repeticoes += 1                 
\end_layout

\begin_layout Plain Layout

			deletado_lista.remove(deletado_lista[cont])                 
\end_layout

\begin_layout Plain Layout

			cont -= 1             
\end_layout

\begin_layout Plain Layout

		cont += 1     
\end_layout

\begin_layout Plain Layout

	return(repeticoes)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dai, a função 
\emph on
teste 
\emph default
é responsável por receber a lista de tuplas, criada no primeiro passo, e
 o parâmetro de comparação e, a partir dai, chamar as funções já explicadas,
 de modo a encontrar a solução desejada, que retornará se há fraude, e o
 número de fraudes em questão.
 
\end_layout

\begin_layout Standard
Através de um argumento funcional denominado filter, na linguagem python,
 toma-se a lista de input e utiliza-se o critério da função 
\emph on
testa_igual 
\emph default
para criar a função das tuplas de códigos de cartões de crédito iguais justapost
os, que será a variável restante demandada pela função 
\emph on
contagem.
 
\emph default
De forma análoga, o mesmo argumento filter toma a mesma lista e utilza do
 critério da função 
\emph on
testa_dif, 
\emph default
para criar a lista das tuplas que não apresentam elementos iguais, lista
 que será utilizada pela funão contagem no input denominado deletado.
 
\end_layout

\begin_layout Standard
A partir daí, a função contagem devolve o número de fraudes, caso haja,
 e assim a função 
\emph on
teste 
\emph default
compara com o parâmetro dado, retornando o argumento lógico 
\emph on
True, 
\emph default
caso o extrapole e o argumento 
\emph on
False,
\emph default
 caso contrário.
 Além disso a função retorna o número de 
\begin_inset Quotes eld
\end_inset

fraudes
\begin_inset Quotes erd
\end_inset

 encontradas.
\end_layout

\begin_layout Standard
A função criada resolve o problema exposto pelo livro, além de apresentar
 um arcobouço geral, que porporciona a aplicação a outros tipos de análise.
 Como será visto a seguir, esse código será alterado, e talvez até simplificado,
 para resolução de um problema real, urgido durante a análise de um dataset.
\end_layout

\begin_layout Subsubsection
Dataset
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Surgiu o desafio de analisar um dataset que apresenta dados de docentes
 brasileiros em atividade em todos os programas de matemática registrados
 na CAPES.
 O desafio consiste em analisar quantos docentes que pesquisam e lecionam
 no mesmo centro que se titularam.
 Essa pergunta é pertinente pois existe uma recomendação da CAPES de que
 a proporção de professores que se titularam e são pesquisadores de um dado
 programa não seja maior que dois terços do quadro.
 
\end_layout

\begin_layout Standard
Dessa forma, acionamos uma base de dados que nos apresenta as instituições
 as quais os docentes se titularam, e os centros que os mesmos trabalharam
 entre 2004 e 2012.
 Nosso desafio foi comparar os casos, verificar a igualdade entre eles e
 reportar se o numero de docentes nos programas de matemática no Brasil
 violam a regra.
 Lançamos mão de analisar instituicão por instituição por fugir do escopo
 da análise, isto é, da contextualização entre o exercicio proposto pelo
 livro e o problema real que nos propusemos a solucionar.
\end_layout

\begin_layout Standard
Um dos desafios da base está no fato de que as strings que correspondem
 às instituições que os docentes se titularam não estão expostas da mesma
 forma que as strings dos centros que os docentes compõem nos anos da análise.
 Assim, se fez necessário um tratamento das strings e a criação de uma função
 responsável por comparações que ao invés de levar um argumento lógico como
 balizador, levou em consideração a função de Levenshtein, função abordada
 mais adiante, para verificar a proximidade das strings.
 
\end_layout

\begin_layout Standard
No entanto, comparada à abordagem linear exposta acima, o fato de o dataset
 apresentar as respectivas instituições em que os professores atuam nos
 anos de análise já casadas com as instituições de titulação facilita a
 análise.
 Dito de outra forma, não existem pares desencontrados, ou valores ímpares
 de características de um mesmo docente, pois cada linha corresponde a um
 docente diferente e busca-se encontrar o número de semelhanças sobre um
 determinado critério.
 
\end_layout

\begin_layout Standard
Com isso, a análise do dataset, teve como desafio a aplicação do caso abstrato
 ao caso real, por intermédio do relaxamento de algumas hipóteses lançadas
 na abordagem linar acima.
 Segue um recorte do dataset para melhor expor a natureza do problema:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Captura de Tela 2015-06-22 às 19.43.57.png
	scale 35

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Recorte do Dataset
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Implementação
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Isto posto, buscamos na versão linear do algoritmo de resolução da questão
 proposta no livro inspiração para resolução de tal problema.
 Somos capazes de criar uma lista de tuplas, as quais farão uma relação
 entre a instituição que o docente atua e a instituição a qual ele se tituolou.
 Uma vez, que essa lista de tuplas é criada, somos capazes de passar por
 cada tupla, comparando em tempo linear, a igualdade entre as strings.
 Como já dito acima, essa comparação é feita por intermedio do algoritmo
 de Levenshtein.
 
\end_layout

\begin_layout Standard
A teoria da distância de Levenshtein entre duas strings, diz respeito ao
 número de operações necessárias para transformar uma string em outra.
 Em nossa análise, tomamos como razoável uma distância de Leveinshtein de
 até dois.
 Segue o algoritmo:
\end_layout

\begin_layout Standard
A primeira parte diz respeito à importação das bibliotecas necessárias para
 análise.
 A 
\emph on
xlrd
\emph default
 é utilizada para importar os dados de uma planilha em excel, enquanto a
 biblioteca 
\emph on
re
\emph default
 é responsável por fazer o tratamento de strings via expressões regulares,
 enquanto a 
\emph on
Levenshtein 
\emph default
diz respeito à distância homonima descrita acima.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import xlrd 
\end_layout

\begin_layout Plain Layout

import re 
\end_layout

\begin_layout Plain Layout

import Levenshtein 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Deixamos a segunda parte da análise para descrever como estruturamos o dado.
 Como já descrito, buscamos as construção de uma lista de tuplas, justapondo
 as instituições que os docentes trabalham e qual eles se titularam respectivame
nte, de modo que a comparação de custo O(1) seja repetida n vezes, o que
 nos traz um custo linear para análise de toda base em questão.
 Assim, segue o exemplo:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#Exemplo meramente ilustrativo, pois não está no dataset real.
 
\end_layout

\begin_layout Plain Layout

lst = [("UFRJ","UERJ"), ("EMAP","EBAPE"), ("PUC Rio","PUC-MG"), ("UFF","FGV"),
 ("EBEF","EPGE"), ("UFRRJ","UFMG")]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Se faz necessário mostrar como limpamos os dados na terceira parte da análise.
 Em primeiro lugar importamos os dados de uma planilha em excel
\begin_inset Foot
status open

\begin_layout Plain Layout
A base de dados é confidencial.
 Faz parte de um projeto de pesquisa junto à EBAPE sobre métodos de avaliação
 da qualidade da educação Superior no Brasil.
\end_layout

\end_inset

, posteriormente necessitamos de expressões regulares para limpar as strings
 das instituições as quais os docentes se titularam pois essa parte do dado
 veio em formatação não usual.
 Por fim, transformamos todas as strings em maiusculas e construimos a lista
 de tuplas como exposto no exemplo acima.
 A descrição corresponde ao seguinte código:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

matematica_wb = xlrd.open_workbook("Matematica.xlsx", encoding_override =
 "utf8" ) 
\end_layout

\begin_layout Plain Layout

matematica_ws = matematica_wb.sheet_by_index(0) 
\end_layout

\begin_layout Plain Layout

instituicao = matematica_ws.col(4)  
\end_layout

\begin_layout Plain Layout

titulacao = matematica_ws.col(52) 
\end_layout

\begin_layout Plain Layout

titulacao_IES = []  
\end_layout

\begin_layout Plain Layout

cont = 0 
\end_layout

\begin_layout Plain Layout

for valor in titulacao:     
\end_layout

\begin_layout Plain Layout

	valor_split = re.split("/",str(valor))     
\end_layout

\begin_layout Plain Layout

	titulacao_IES.append((str(instituicao[cont]).upper(),valor_split[0].upper()))
     
\end_layout

\begin_layout Plain Layout

	cont += 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Iniciamos no indice 1, pois não nos interessamos no titulo.
 
\end_layout

\begin_layout Plain Layout

lst_tit_ies = titulacao_IES[1:]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A partir de agora, serão expostas as funções necessárias para verificar
 a semelhança entre as strings, realizar a contagem entre elas, e por fim
 verificar o número de casos de igualdade.
 A primeira função a ser abordade será a de comparações, que nesse caso
 será chamada de 
\emph on
teste_igual
\emph default
.

\emph on
 
\emph default
A função toma dois valores, compara a distância de Levenshtein entre eles
 e retorna o número um caso esse nível de distância seja abaixo de 2 e retorna
 o número zero caso contrário.
 
\end_layout

\begin_layout Standard
Repara-se que a função 
\emph on
teste_igual
\emph default
 é uma variação da função 
\emph on
compara
\emph default
 explicada na implementação da abordagem linear.
 A alteração se faz necessária, pois estamos interessados em contar casos
 que consideramos próximos, assim, de forma recursiva vamos chamar tal função
 para comparar e retornar tais valores que proporcionarão a capacidade de
 contagem.
 
\end_layout

\begin_layout Standard
Além disso, a complexidade dessa função é de O(1), pois toma dois valores
 e os compara através de um argumento lógico.
 Segue o código da função em questão.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

#A variavel valor é uma tupla
\end_layout

\begin_layout Plain Layout

def testa_igual(valor):     
\end_layout

\begin_layout Plain Layout

	distancia_str = Levenshtein.distance(valor[0],valor[1])     
\end_layout

\begin_layout Plain Layout

	if distancia_str <= 2:         
\end_layout

\begin_layout Plain Layout

		return(1)     
\end_layout

\begin_layout Plain Layout

	else:         
\end_layout

\begin_layout Plain Layout

		return(0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Uma vez que a função 
\emph on
teste_igual
\emph default
 está definida podemos descrever a função 
\emph on
contagem
\emph default
.
 A função contagem toma uma lista de tuplas, e chama de forma recursiva
 suas metades de forma a otimizar a contagem do número e valores iguais
 entre instituições de trabalho e de titulação.
 
\end_layout

\begin_layout Standard
Assim, o passo base consiste em comparar através da função 
\emph on
teste_igual 
\emph default
a igualdade das tuplas e contando os valores de contagem de metade da lista
 e os somando ao final de cada chamada.
 
\end_layout

\begin_layout Standard
Dessa forma, o algoritmo retorna exatamente o número de casos em que a distância
 de Levenshtein das strings é menor ou igual a dois para todas os docentes
 nos anos de análise.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

def contagem(lista):     
\end_layout

\begin_layout Plain Layout

	if len(lista) is 0:         
\end_layout

\begin_layout Plain Layout

		return(0)     
\end_layout

\begin_layout Plain Layout

	if len(lista) is 1:         
\end_layout

\begin_layout Plain Layout

		return(testa_igual(lista[0]))     
\end_layout

\begin_layout Plain Layout

	else:         
\end_layout

\begin_layout Plain Layout

		med =len(lista)//2         
\end_layout

\begin_layout Plain Layout

		return(contagem(lista[:med]) + contagem(lista[med:]))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Por fim, expomos a função responsável por receber a lista com os dados e
 chamar as funções já explicadas anteriormente, para que com os outputs
 das funções já explicadas, ela possa fazer a comparação entre o tamanho
 de casos de igualdade o parâmetro de análise.
 
\end_layout

\begin_layout Standard
Como já citado, buscamos comparar a incidência de casos em que há igualdade
 de docentes com dois terços do número de docentes no pais.
 Assim, o nosso parametro será o valor correspondente a dois terços do número
 de observações totais.
 Caso seja maior, retornamos o lógico 
\emph on
True, 
\emph default
responsável por designar que mais de dois terços dos professores brasileiros
 se titularam na mesma insituição que trabalham.
 Caso a função contagem não extrapole o parametro dado como input, o retorno
 será o lógico 
\emph on
False
\emph default
.
 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def verifica(universidades,parametro):     
\end_layout

\begin_layout Plain Layout

	if contagem(universidades) > parametro:
\end_layout

\begin_layout Plain Layout

		return(True,contagem(universidades))     
\end_layout

\begin_layout Plain Layout

	else:         
\end_layout

\begin_layout Plain Layout

		return(False,contagem(universidades))
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Conclusão
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Em resumo, busca-se através desse algortimo enfrentar um desafio real de
 análise de dados de educação superior no Brasil.
 A resolução em tempo linear do exercício proposto, já explicado acima,
 serviu de inspiração para criação desse código, que nos levou a inferir
 que 2105 docentes se titularam e trabalham no mesmo centro.
 
\end_layout

\begin_layout Standard
Destaca-se que a análise é uma aproximação que pode estar levando em consideraçã
o repetições ou deixando de tomar casos de interesse, uma vez que as strings
 não estão expostas no mesmo formato e o dado está em painel.
 Apesar dos desafios, foi construído um código em tempo de complexidade
 O(nlogn), que retornou o lógico 
\emph on
False, 
\emph default
pois a base tem tamanho de 9322 observações.
\end_layout

\begin_layout Subsection
Exercício Selecionado 4
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Este exercício foi extraído do capítulo 8 do livro 
\emph on
Algorithms 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "Dasgupta2006"

\end_inset


\emph on
, 
\emph default
sendo o exercício 8.3.
 Este capítulo discute problemas da classe NP e da classe NP-completo, destacand
o a redução de problemas NP-completo conhecidos para outros problemas de
 interesse, com a finalidade de mostrar que os problemas de interesse também
 são da classe NP-completo.
 O problema apresentado a seguir é, justamente, um problema de redução e
 sua escolha foi motivada pelo interesse em buscar um maior entendimento
 sobre o assunto.
\end_layout

\begin_layout Subsubsection
Enunciado
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\emph on
STINGY SAT
\emph default
 é o nome dado ao seguinte problema: Dado um conjunto de cláusulas (cada
 cláusula é uma disjunção de literais) e um inteiro 
\emph on
k
\emph default
, encontre uma solução que satisfaça o conjunto de cláusulas com 
\bar under
no máximo
\bar default
 
\emph on
k
\emph default
 variáveis iguais a 
\emph on
true
\emph default
, se esta solução existir.
 
\end_layout

\begin_layout Standard
Pede-se para provar que 
\emph on
STINGY SAT
\emph default
 é NP-completo.
\end_layout

\begin_layout Subsubsection
Discussão
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para provar que um dado problema é NP-completo, podemos mostrar que é possível
 reduzir um problema conhecido da classe NP-completo para este problema.
 Sendo assim, neste contexto, basta reduzirmos o problema SAT para o problema
 STINGY SAT.
\end_layout

\begin_layout Subsubsection*
Uma breve descrição de SAT
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
O problema de satisfabilidade booleana (SAT) consiste de determinar se existe
 uma valoração para as variáveis de uma dada fórmula na forma normal conjuntiva
 (conjunto de cláusulas que consistem em disjunções de literais) tal que
 esta valoração torne a fórmula verdadeira, ou seja a valoração satisfaz
 a fórmula que é dita satisfatível.
\end_layout

\begin_layout Subsubsection*
A redução 
\bar under
SAT
\begin_inset Formula $\rightarrow$
\end_inset

STINGY SAT
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A redução do problema de satisfabilidade para o problema 
\emph on
mesquinho
\emph default
 (tradução livre) de satisfabilidade ocorre de maneira simples, uma vez
 que a entrada do problema de SAT é bastante similar à entrada do problema
 STINGY SAT, pois as duas entradas diferem apenas pelo inteiro 
\emph on
k
\emph default
.
 O inteiro 
\emph on
k 
\emph default
será determinado pelo número N de literais presentes na fórmula fornecida
 como entrada para o problema SAT, de forma que o problema STINGY SAT irá
 retornar se é possível satisfazer a fórmula dada com no máximo N variáveis
 verdadeiras.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\left\{ \begin{array}{c}
(a_{1}\vee a_{2}\vee...\lor a_{n})\\
entrada\,de\,SAT
\end{array}\right\} \Longleftrightarrow\left\{ \begin{array}{c}
(a_{1}\vee a_{2}\vee...\lor a_{n}),\;inteiro\,k=n\\
entrada\,de\,STINGY\,SAT
\end{array}\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename sat/Screen Shot 2015-06-22 at 19.31.46.png
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Redução SAT-STINGY SAT
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Implementação
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Tendo sido provado que o problema STINGY SAT é NP-completo é possível implementa
r a redução em ambos sentidos: SAT
\begin_inset Formula $\rightarrow$
\end_inset

STINGY SAT e STINGY SAT
\begin_inset Formula $\rightarrow$
\end_inset

SAT.
 Para testar a redução STINGY SAT
\begin_inset Formula $\rightarrow$
\end_inset

SAT implementada utilizou-se o pacote 
\emph on
pycosat 
\emph default
do Python o qual implementa a resolução do problema SAT.
 Este pacote representa as cláusulas como conjunto de lista de inteiros
 que representam os literais da fórmula,tal que:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
(A\vee B\vee C)\wedge(\lnot A\vee\lnot B\vee C)\,equivale\,a\;[\,[1,2,3],\,[-1,-2,3]\,]
\]

\end_inset


\end_layout

\begin_layout Standard
Para tornar a construção das fórmulas mais intuitivas, implementou-se uma
 classe para construção das fórmulas, de forma que o usuário entre com a
 seguinte fórmula:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

clause = cnf.AND(cnf.OR("A",cnf.NOT("E"),"D"),cnf.OR(cnf.NOT("A"),"E","C","D"),cnf.OR(
cnf.NOT("C"),cnf.NOT("B")))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Esta seja transformada em uma entrada equivalente do pacote 
\emph on
pycosat:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

clause =[[1,-5,4],[-1,5,3,4],[-3,-2]] 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Os métodos implementados são apresentados a seguir e cosistem de um simples
 parser para a fórmula de entrada.
 Cada uma das operações (AND, OR e NOT) foi implementada como um método
 que pode receber um número variável de parâmetros.
 Os parâmetros são strings (literais) ou um valor de retorno de uma outra
 operação (operação entre literais).
 Os métodos compõe uma classe denominada CNF que possui uma atributo do
 tipo dicionário chamada 
\emph on
variables 
\emph default
que relaciona os literais fornecidos em forma de string com os inteiros
 a serem passados para o resolvedor do 
\emph on
pycosat; 
\emph default
além disso a classe possui um atributo
\emph on
 clause 
\emph default
que armazena a f'órmula na forma de lista de inteiros (compatível com 
\emph on
pycosat
\emph default
).
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

class CNF:
\end_layout

\begin_layout Plain Layout

	#Inicialização do dicionário de variáveis da fórmula e da fórmula	
\end_layout

\begin_layout Plain Layout

	def __init__(self): 		
\end_layout

\begin_layout Plain Layout

		self.variables = {}
\end_layout

\begin_layout Plain Layout

		self.clause = []
\end_layout

\begin_layout Plain Layout

	#Cada parâmetro da função AND é uma dijunção de literais (lista de literais
 retornados pela função OR)
\end_layout

\begin_layout Plain Layout

	def AND(self, *args): 			
\end_layout

\begin_layout Plain Layout

		for arg in args: 			
\end_layout

\begin_layout Plain Layout

			if isinstance(arg, list): 				
\end_layout

\begin_layout Plain Layout

				self.clause.append(arg) 			
\end_layout

\begin_layout Plain Layout

			else: 				
\end_layout

\begin_layout Plain Layout

				return "Invalid CNF format" 		
\end_layout

\begin_layout Plain Layout

		return self.clause
\end_layout

\begin_layout Plain Layout

	#Cada parâmetro da função OR é uma string que corresponde a um literal
 ou 
\end_layout

\begin_layout Plain Layout

	#um inteiro (retornado pela função NOT) que corresponde ao valor negado
 de um literal 
\end_layout

\begin_layout Plain Layout

	def OR(self, *args): 		
\end_layout

\begin_layout Plain Layout

		clause=[] 		
\end_layout

\begin_layout Plain Layout

		for arg in args:
\end_layout

\begin_layout Plain Layout

			#verifica se o valor é um inteiro			
\end_layout

\begin_layout Plain Layout

			if isinstance(arg, int): 				
\end_layout

\begin_layout Plain Layout

				clause.append(arg) 			
\end_layout

\begin_layout Plain Layout

			else:
\end_layout

\begin_layout Plain Layout

				#verifica se o parâmetro é uma string				
\end_layout

\begin_layout Plain Layout

				if isinstance(arg, basestring): 
\end_layout

\begin_layout Plain Layout

					#armazena a string se ela não estiver no dicionário					
\end_layout

\begin_layout Plain Layout

					if not arg in self.variables: 						
\end_layout

\begin_layout Plain Layout

						self.variables[arg] = len(self.variables) 					
\end_layout

\begin_layout Plain Layout

					clause.append(self.variables[arg]) 				
\end_layout

\begin_layout Plain Layout

				else: 					
\end_layout

\begin_layout Plain Layout

					return "Invalid CNF format" 		
\end_layout

\begin_layout Plain Layout

		return clause
\end_layout

\begin_layout Plain Layout

	#Este parâmetro é uma string que corresponde a um literal 
\end_layout

\begin_layout Plain Layout

	def NOT(self,variable):
\end_layout

\begin_layout Plain Layout

		#verifica se o parâmetro é uma string			
\end_layout

\begin_layout Plain Layout

		if isinstance(variable, basestring): 
\end_layout

\begin_layout Plain Layout

			#armazena a string se ela não estiver no dicionário				
\end_layout

\begin_layout Plain Layout

			if not variable in self.variables: 				
\end_layout

\begin_layout Plain Layout

				self.variables[variable] = len(self.variables) 			
\end_layout

\begin_layout Plain Layout

			return -self.variables[variable] 		
\end_layout

\begin_layout Plain Layout

		else: 			
\end_layout

\begin_layout Plain Layout

			return "Invalid CNF format"
\end_layout

\begin_layout Plain Layout

	#Retorna o número de literais presentes na fórmula
\end_layout

\begin_layout Plain Layout

	def NUMBER_OF_VARIABLES(self): 		
\end_layout

\begin_layout Plain Layout

		return len(self.variables)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As reduções implementadas são apresentadas a seguir, a redução de SAT para
 STINGY SAT foi implementada segundo a equivalência entre as entradas explicada
 anteriormente.
 A idéia da redução do problema STINGY SAT para o SAT consiste de analisar
 as valorações que satisfazem a fórmula fornecida como entrada, retornadas
 pelo SAT e verificar se para alguma dessas valorações existem no máximo
 
\emph on
k 
\emph default
variáveis verdadeiras.
 Se houver, então o STINGY SAT deve retornar verdadeiro, se não houver deve
 retornar falso.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#recebe a instância da classe CNF criada para armazenar a fórmula de entrada
\end_layout

\begin_layout Plain Layout

def reduceSatToStingySAT(cnf): 	
\end_layout

\begin_layout Plain Layout

  return STINGYSAT(cfn.clause, cnf.NUMBER_OF_VARIABLES())
\end_layout

\begin_layout Plain Layout

#recebe a instância da classe CNF criada para armazenar a fórmula de entrada
\end_layout

\begin_layout Plain Layout

def reduceStingySatToSAT(cnf, k): 	
\end_layout

\begin_layout Plain Layout

	solutions = SAT(cnf.clause) 
\end_layout

\begin_layout Plain Layout

	#Conta o número de variáveis verdadeir para cada valoração que satisfaz
 a fórmula	
\end_layout

\begin_layout Plain Layout

	for solution in solutions: 	
\end_layout

\begin_layout Plain Layout

		#se encontra uma valoração com k variáveis verdadeiras retorna verdadeiro
 	
\end_layout

\begin_layout Plain Layout

		if k == countTrueVariables(solution): 			
\end_layout

\begin_layout Plain Layout

			return "TRUE" 	
\end_layout

\begin_layout Plain Layout

	return "FALSE"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finalmente, apresenta-se o método resolvedor de SAT no qual utiliza-se o
 método 
\emph on
itersolve
\emph default
 do pacote 
\emph on
pycosat, 
\emph default
este método retorna todas as valorações que satisfazem uma determinada fórmula.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def SAT(clause): 	
\end_layout

\begin_layout Plain Layout

	return list(pycosat.itersolve(clause))
\end_layout

\end_inset


\end_layout

\begin_layout Section
Conclusão
\end_layout

\begin_layout Standard
Em resumo, esse artigo aborda os diferentes conceitos estudados no curso
 de Estutura de Dados e Algoritmos de uma forma não convencional, pois busca-se
 a contextualização de problemas reais com a abordagem de soluções de problemas
 clássicos.
 Além disso, busca discutir problemas não tratáveis de forma criteriosa,
 de modo a explorar o tema de algoritmos desde os casos mais simples, até
 o mais complexos, sem deixar de encarar com relevância a aplicação das
 resoluções discutidas a possíveis problemas reais, como no caso do dataset
 que aborda dados de educação superior no Brasil.
 Dessa forma, destaca-se a busca por abordar 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "bibliografia"
options "abntex2-num"

\end_inset


\end_layout

\end_body
\end_document
