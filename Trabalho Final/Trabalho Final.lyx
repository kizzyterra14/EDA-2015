#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\begin_preamble
\renewcommand \thefigure{Figura~\@arabic\c@figure}
\def\fps@figure{tbp}
\def\ftype@figure{1}
\def\ext@figure{lof}
\def\fnum@figure{\thefigure}
\definecolor{green}{RGB}{0, 100, 0}
\definecolor{red4}{RGB}{139, 0, 0}
\definecolor{keywords}{RGB}{0,104,139}
\definecolor{gray}{RGB}{162, 181, 205}
\definecolor{Strings}{rgb}{0,0.63,0}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language brazilian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing onehalf
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3.5cm
\topmargin 3.5cm
\rightmargin 3.5cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "aboveskip={0.5cm},basicstyle={\small\ttfamily},breaklines=true,captionpos=b,commentstyle={\itshape\color{gray}},keywords={import,from,class,def,for,while,if,is,in,elif,else,not,and,or,print,break,continue,return,access,as,,del,except,exec,finally,global,lambda,pass,print,raise,try,assert},keywordstyle={\color{keywords}\bfseries},ndkeywords={len,range, None},ndkeywordstyle={\color{red4}\bfseries},stringstyle={\color{Strings}},tab=true,tabsize=3,xleftmargin={1cm},xrightmargin={1cm}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center

\size large
FUNDAÇÃO GETÚLIO VARGAS
\end_layout

\begin_layout Standard
\align center

\size large
ESCOLA DE MATEMÁTICA APLICADA
\end_layout

\begin_layout Standard
\align center

\size large
MESTRADO 2015.1
\end_layout

\begin_layout Standard
\align center

\size large
ESTRUTURA DE DADOS E SEUS ALGORITMOS
\end_layout

\begin_layout Standard
\align center

\size large
Prof Alexandre Rademaker
\end_layout

\begin_layout Standard
\begin_inset VSpace 3cm
\end_inset


\end_layout

\begin_layout Standard
\align center

\size large
Apresentação e discussão dos exercícios selecionados
\end_layout

\begin_layout Standard
\begin_inset VSpace 3cm
\end_inset


\end_layout

\begin_layout Standard
\align center
ALUNOS:
\end_layout

\begin_layout Standard
\align center
KIZZY TERRA
\end_layout

\begin_layout Standard
\align center
OTTO TAVARES
\end_layout

\begin_layout Standard
\begin_inset VSpace 3cm
\end_inset


\end_layout

\begin_layout Standard
\align center
RIO DE JANEIRO
\end_layout

\begin_layout Standard
\align center
JUNHO DE 2015
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Introdução
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Este relatório reúne comentários e implementações dos exercícios selecionados
 cujos enunciados foram previamente apresentados em sala de aula.
 O objetivo deste documento é, acima de tudo, apresentar as interessantes
 discussões que emergiram a medida que os exercícios foram sendo analisados
 e solucionados, ultrapassando a mera exposição da resposta final encontrada
 para cada questão escolhida.
 Cabe ressaltar que alguns dos exercícios selecionados foram utilizados
 apenas como ponto de partida para discussões mais enriquecedoras a fim
 de proporcionar maior aprendizado e possibilitando os conhecimentos adquiridos
 ao longo do curso fossem, de fato, colocados em prática.
\end_layout

\begin_layout Section
Exercícios selecionados
\end_layout

\begin_layout Subsection
Exercício Selecionado 1
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Este exercício foi extraído do livro 
\emph on
Algorithms
\begin_inset CommandInset citation
LatexCommand cite
key "Dasgupta2006"

\end_inset

, 
\emph default
capítulo 6, sendo o exercício 6.1.
 O enunciado deste exercício refere-se a um conhecido problema de programação
 dinâmica: subsequência de soma máxima.
 Este problema consiste de encontrar a subsequência de números com maior
 soma dentro de lista de números unidimensional dada.
 Este problema possui duas principais variações unidimensionais: na primeira,
 consideram-se apenas subsequências contíguas da lista de números; na segunda,
 por sua vez, as subsequências podem envolver números que não são contíguos.
 
\end_layout

\begin_layout Standard
O problema da subsequência contígua de soma máxima foi proposto pela primeira
 vez em 1977 por Ulf Grenander da 
\emph on
Brown University, 
\emph default
como um modelo simplificado do problema de estimativa de padrões por máxima
 verossimilhança em imagem digitalizadas.
 O problema original do estimador de máxima verossimilhança é na verdade
 um problema de subsequência de soma máxima bidimensional, mas foi proposto
 por Grenander em sua forma simplificada (unidimensional) visto que o problema
 bidimensional exigia mais tempo para ser resolvido.
 Uma solução de tempo linear para o problema unidimensional foi encontrada
 pouco tempo depois que o problema foi proposto por Jay Kadane da 
\emph on
Carnegie-Mellon University.
\begin_inset CommandInset citation
LatexCommand cite
key "Bentley1984"

\end_inset


\end_layout

\begin_layout Standard

\emph on
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsubsection
A primeira versão
\end_layout

\begin_layout Subsubsection*
Problema: Subsequência contígua de soma máxima
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Entrada: Uma lista de números 
\begin_inset Formula $a_{1}$
\end_inset

, 
\begin_inset Formula $a_{2}$
\end_inset

, 
\begin_inset Formula $a_{3}$
\end_inset

, 
\begin_inset Formula $\ldots$
\end_inset

 , 
\begin_inset Formula $a_{n}$
\end_inset


\end_layout

\begin_layout Standard
Saída: A subsequência contígua de soma máxima (uma subsequência de tamanho
 zero possui soma zero)
\end_layout

\begin_layout Subsubsection*
Discussão
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A solução mais ingênua que se pode dar para esta questão consiste de um
 algoritmo força bruta que calcula todas as possíveis combinações de subsequênci
as, calcula a soma para cada uma delas e retorna a subsequência correspondente
 a maior soma encontrada.
 A seguir é apresentada a implementação desta abordagem ingênua em Python.
 
\end_layout

\begin_layout Paragraph*
Implementação
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard

\emph on
Descrição das variáveis utilizadas 
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
L: 
\emph default
lista de números (entrada)
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
sizeL: 
\emph default
tamanho da entrada L
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
max_sum: 
\emph default
armazena o valor da soma máxima.
 É inicializada com o valor do primeiro elemento da lista de números e é
 atualizada, durante a execução, a medida que são encontradas somas maiores
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
max_subsequence:
\emph default
 armazena os elementos que compõe a subsequência de soma máxima
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
current_sum: 
\emph default
armazena o valor da soma para cada iteração de 
\emph on
i
\emph default
 (laço 
\emph on
for 
\emph default
intermediário)
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout
\align left

def cubic(L):
\end_layout

\begin_layout Plain Layout

	sizeL = len(L)
\end_layout

\begin_layout Plain Layout

	if sizeL == 0:
\end_layout

\begin_layout Plain Layout

		return L
\end_layout

\begin_layout Plain Layout

	max_sum = L[0]
\end_layout

\begin_layout Plain Layout

	max_subsequence = L[:1]
\end_layout

\begin_layout Plain Layout

	for j in range(1, sizeL):
\end_layout

\begin_layout Plain Layout

		for i in range(j): 
\end_layout

\begin_layout Plain Layout

			current_sum = 0
\end_layout

\begin_layout Plain Layout

			for k in range(i,j):
\end_layout

\begin_layout Plain Layout

				current_sum += L[k]
\end_layout

\begin_layout Plain Layout

			if current_sum > max_sum:
\end_layout

\begin_layout Plain Layout

				max_sum = current_sum
\end_layout

\begin_layout Plain Layout

				max_subsequence = L[i:j]
\end_layout

\begin_layout Plain Layout

	return max_subsequence
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
O método implementado possui três laços 
\emph on
for 
\emph default
encadeados e cada um deles irá iterar no máximo N vezes, em que N é o número
 de elemntos da lista de números dada como entrada, portanto a complexidade
 deste algoritmo é 
\begin_inset Formula $O(N^{3})$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Solução quadrática
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A solução cúbica apresentada é claramente ineficiente e por essa razão,
 basta pensar um pouco para identificar que podemos modificá-la facilmente
 e torná-la ligeiramente melhor, isso pode ser feito apenas eliminando o
 laço 
\emph on
for 
\emph default
mais interno, como segue:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

def quadratic(L):
\end_layout

\begin_layout Plain Layout

	sizeL = len(L)
\end_layout

\begin_layout Plain Layout

	if sizeL == 0:
\end_layout

\begin_layout Plain Layout

		return L
\end_layout

\begin_layout Plain Layout

	max_sum = L[0]
\end_layout

\begin_layout Plain Layout

	max_subsequence = L[:1]
\end_layout

\begin_layout Plain Layout

	for j in range(sizeL):
\end_layout

\begin_layout Plain Layout

		current_sum = 0
\end_layout

\begin_layout Plain Layout

		for i in range(j, sizeL):
\end_layout

\begin_layout Plain Layout

			current_sum += L[i]
\end_layout

\begin_layout Plain Layout

			if current_sum > max_sum:
\end_layout

\begin_layout Plain Layout

				max_sum = current_sum
\end_layout

\begin_layout Plain Layout

				max_subsequence = L[i:j+1]
\end_layout

\begin_layout Plain Layout

	return max_subsequence
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Esta implementação possui dois laços
\emph on
 for
\emph default
 encadeados e cada um será executado N vezes, no pior caso, logo a complexidade
 do algoritmo apresentado é 
\begin_inset Formula $O(N^{2})$
\end_inset

.
 
\end_layout

\begin_layout Standard
Embora o algoritmo quadrático seja mais eficiente do que o algoritmo cúbico,
 é possível propor soluções ainda melhores.
 A seguir será discutida uma solução linear similiar à solução proposta
 por Kadane na ocasião em que o problema foi proposto.
\end_layout

\begin_layout Subsubsection*
A solução linear
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A idéia para esta implementação é utilizar a técnica de programação dinâmica,
 isto é, construir a solução de um problema através da solução de subproblemas
 associados.
 Neste contexto, a principal idéia é considerar que para cada elemento I
 da lista de números a solução procurada (subsequência contígua de soma
 máxima) pode ser encontrada a partir da solução calculada para o elemento
 anteiror I - 1(se existir), beneficiando-se do fato de que duas somas parciais
 vizinhas computadas ao longo da execução diferem por apenas um elemento.
 
\end_layout

\begin_layout Paragraph*
Implementação
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard

\emph on
Descrição das variáveis utilizadas
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
startSoFar: 
\emph default
armazena o índice do elemento que inicia a subsequência de maior soma
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
startPrevious: 
\emph default
armazena o índice do elemento que inicia a subsequência de maior soma encontrada
 na iteração anterior
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
endSoFar:
\emph default
 armazena o índice do elemento que encerra a subsequência de maior soma
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
maxSoFar:
\emph default
 armazena o valor da subsoma máxima.
 É inicializada com o valor do primeiro elemento da lista de números e é
 atualizada, durante a execução, a medida que são encontradas somas maiores
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
maxPrevious:
\emph default
 armazena o valor da subsoma máxima encontrada na iteração anterior.
 É inicializada com o valor do primeiro elemento da lista de números e é
 atualizada, durante a execução, a medida que são encontradas somas maiores
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
O algortimo inicia-se com a inicialização das variáveis conforme descrito
 e em seguida implementa-se um laço 
\emph on
for 
\emph default
para calcular a solução do problema para cada elemento I (em cada iteração
 calcula-se a resposta para o problema como se a lista de números terminasse
 no elemento I), para isso verifica-se qual subsequência possui maior soma:
 a subsequência composta por todos os elementos até I (
\begin_inset Formula $S[I-1]\cup L[I]$
\end_inset

 ) ou a subsequência que se inicia em I(
\begin_inset Formula $S[I]=\{L[I]\}$
\end_inset

).
 Uma vez encontrada a melhor solução para a iteração as variáveis auxiliares
 são devidamente atualizadas: caso a subsoma encotrada ao final de uma determina
da iteração (
\emph on
maxPrevious
\emph default
) seja maior que a subsoma máxima encontrada em todas as iterações anteriores
 (
\emph on
maxSoFar
\emph default
), então as variáveis 
\emph on
maxSoFar
\emph default
, 
\emph on
startSoFar
\emph default
 e 
\emph on
endSoFar
\emph default
 são modificadas.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

if maxPrevious + L[i] >= L[i]:             
\end_layout

\begin_layout Plain Layout

	maxPrevious = maxPrevious + L[i]         
\end_layout

\begin_layout Plain Layout

else:            
\end_layout

\begin_layout Plain Layout

	startPrevious = i             
\end_layout

\begin_layout Plain Layout

	maxPrevious = L[i]         
\end_layout

\begin_layout Plain Layout

if maxPrevious >= maxSoFar:             
\end_layout

\begin_layout Plain Layout

	maxSoFar = maxPrevious             
\end_layout

\begin_layout Plain Layout

	endSoFar = i             
\end_layout

\begin_layout Plain Layout

	startSoFar = startPrevious     
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ao final de todas as iterações a subsequência de soma máxima é retornada.
 O método completo é apresentado a seguir:
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

def linear(L):
\end_layout

\begin_layout Plain Layout

	startSoFar = 0     
\end_layout

\begin_layout Plain Layout

	startPrevious = 0     
\end_layout

\begin_layout Plain Layout

	endSoFar = 0     
\end_layout

\begin_layout Plain Layout

	maxSoFar = L[0]     
\end_layout

\begin_layout Plain Layout

	maxPrevious = L[0] 
\end_layout

\begin_layout Plain Layout

	for i in range(1,len(L)):         
\end_layout

\begin_layout Plain Layout

		if maxPrevious + L[i] >= L[i]:             
\end_layout

\begin_layout Plain Layout

			maxPrevious = maxPrevious + L[i]         
\end_layout

\begin_layout Plain Layout

		else:            
\end_layout

\begin_layout Plain Layout

			startPrevious = i             
\end_layout

\begin_layout Plain Layout

			maxPrevious = L[i]         
\end_layout

\begin_layout Plain Layout

		if maxPrevious >= maxSoFar:             
\end_layout

\begin_layout Plain Layout

			maxSoFar = maxPrevious             
\end_layout

\begin_layout Plain Layout

			endSoFar = i             
\end_layout

\begin_layout Plain Layout

			startSoFar = startPrevious 
\end_layout

\begin_layout Plain Layout

	return L[startSoFar:endSoFar+1]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
No método apresentado o laço 
\emph on
for 
\emph default
é o único bloco da implementação que depende do tamanho da entrada e este
 laço irá executar N vezes, e para cada iteração irá executar um número
 constante de operações O(1), portanto a complexidade desta solução é 
\begin_inset Formula $O(N)$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
A segunda versão
\end_layout

\begin_layout Subsubsection*
Problema: Subsequência de soma máxima
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Entrada: Uma lista de números 
\begin_inset Formula $a_{1}$
\end_inset

, 
\begin_inset Formula $a_{2}$
\end_inset

, 
\begin_inset Formula $a_{3}$
\end_inset

, 
\begin_inset Formula $\ldots$
\end_inset

 , 
\begin_inset Formula $a_{n}$
\end_inset


\end_layout

\begin_layout Standard
Saída: A subsequência (não necessariamente contígua) de maior soma
\end_layout

\begin_layout Subsubsection*
Discussão
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para esta versão do problema em que os números que compõe a sequência a
 ser retornada podem ser não-adjacentes, as soluções apresentadas na seção
 anterior não podem ser utilizadas, visto que naquelas implementações memorizava
-se a solução parcial encontrada a cada iteração para que fosse utilizada
 no cálculo da solução parcial da iteração seguinte.
 Entretanto, para que se possa encontrar a solução correta para este caso,
 é necessário calcular a solução parcial em uma determinada iteração em
 relação a todas as iterações anteriores, e não apenas em relação a solução
 parcial imediatamente anteiror como fazia-se na seção 2.1.1.
 A seguir será apresentada uma solução com complexidade de tempo quadrática
 no tamanho da entrada.
\end_layout

\begin_layout Subsubsection*
Uma solução quadrática
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Esta implementação utiliza a técnica de programação dinâmica através do
 armazenamento de resultados intermediários calculados ao longo da execução.
 A idéia deste algoritmo consiste de calcular a solução para uma determinada
 iteração levando-se em consideração todos os resultados previamente calculados
 de modo que a subsequência de soma máxima encontrada para a iteração será:
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\noindent

\size footnotesize
\begin_inset Formula 
\[
subseqMax(i)=max\{max\{subseqMax(k)\cup elemento(i);\, k<i\},\; elemento(i)\}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Isto é, a subsequência de soma máxima para uma dada iteração I é calculada
 comparando as somas das subsequências encontradas nas iterações anteriores
 adicionadas do elemento I com o próprio elemento I.
 Estas comparações executadas a cada iteração tornam esta solução quadrática,
 uma vez que o número de comparações por iteração é (I-1) e são realizadas
 N iterações no total, onde N é o tamanho da entrada, logo a complexidade
 de tempo do algoritmo é 
\begin_inset Formula $O(N^{2})$
\end_inset

.
 Nesta solução a complexidade de espaço também depende do tamanho da entrada,
 uma vez que armazena-se os resultados intermediários obtidos para as N
 iterações, tornando a complexidade espacial 
\begin_inset Formula $O(N)$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Paragraph*
Implementação
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard

\emph on
Descrição das variáveis utilizadas 
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
L : 
\emph default
lista de números
\emph on
 
\emph default
(entrada)
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
sizeL : 
\emph default
tamanho da entrada
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
maxSoFar_index: 
\emph default
armazena o índice do último elemento da subsequência de soma máxima.
 É inicializado com zero, sendo atualizado a medida que subsequências com
 somas maiores são encontradas
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
maxSum: 
\emph default
array de tamanho N que armazena em cada posição 
\emph on
k
\emph default
 o valor da soma da subsquência de soma máxima encontrada para a posição
 
\emph on
k.
 
\emph default
É inicializado com os elementos da entrada L
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
subsequence: 
\emph default
array de tamanho N utlilizado para recuperar os elementos que compõe a subsequên
cia de soma máxima.
 Cada posição corresponde a um elemento 
\emph on
i 
\emph default
e armazena o índice do elemento que o antecede na subsequência de soma máxima.
 Os elementos deste array são inicializados com valor -1.
\end_layout

\begin_layout Standard
\begin_inset space \quad{}
\end_inset


\emph on
max_subsequence: 
\emph default
armazena os elementos que compõe a subsequência de soma máxima
\end_layout

\begin_layout Standard
A algortimo inicia-se com a inicialização das variáveis conforme descrito
 e em seguida implementa-se dois laços for encadeados para encontrar os
 resultados intermediários para cada um dos elementos da lista.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	for i in range(1,sizeL):    
\end_layout

\begin_layout Plain Layout

		for j in range(i):                            
\end_layout

\begin_layout Plain Layout

			if maxSum[j] + L[i] >= maxSum[i]:                                
\end_layout

\begin_layout Plain Layout

				subsequence[i] = j                                
\end_layout

\begin_layout Plain Layout

				maxSum[i] = maxSum[j] + L[i]                                 
\end_layout

\begin_layout Plain Layout

		if maxSum[i] >= maxSum[maxSoFar_index]:                     
\end_layout

\begin_layout Plain Layout

			maxSoFar_index = i 
\end_layout

\begin_layout Plain Layout

          
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ao final de todas as iterações recupera-se a subsequência de soma máxima
 utilizando-se o array 
\emph on
subsequence
\emph default
 e é armazenada no array 
\emph on
max_subsequence 
\emph default
para ser retornada.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

k = maxSoFar_index
\end_layout

\begin_layout Plain Layout

while k != -1 :            
\end_layout

\begin_layout Plain Layout

	max_subsequence.append(L[k])            
\end_layout

\begin_layout Plain Layout

	k = subsequence[k]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
O método completo é apresentado a seguir:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

def quadratic(L):
\end_layout

\begin_layout Plain Layout

	sizeL = len(L)
\end_layout

\begin_layout Plain Layout

	if sizeL < 1:
\end_layout

\begin_layout Plain Layout

		return L
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	maxSoFar_index = 0
\end_layout

\begin_layout Plain Layout

	maxSum = []
\end_layout

\begin_layout Plain Layout

	subsequence = []
\end_layout

\begin_layout Plain Layout

	for i in range(sizeL):         
\end_layout

\begin_layout Plain Layout

		maxSum.append(L[i]) 
\end_layout

\begin_layout Plain Layout

	for i in range(sizeL):          
\end_layout

\begin_layout Plain Layout

		subsequence.append(-1) 
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	for i in range(1,sizeL):    
\end_layout

\begin_layout Plain Layout

		for j in range(i):                            
\end_layout

\begin_layout Plain Layout

			if maxSum[j] + L[i] >= maxSum[i]:                                
\end_layout

\begin_layout Plain Layout

				subsequence[i] = j                                
\end_layout

\begin_layout Plain Layout

				maxSum[i] = maxSum[j] + L[i]                                 
\end_layout

\begin_layout Plain Layout

		if maxSum[i] >= maxSum[maxSoFar_index]:                     
\end_layout

\begin_layout Plain Layout

			maxSoFar_index = i 
\end_layout

\begin_layout Plain Layout

          
\end_layout

\begin_layout Plain Layout

	k = maxSoFar_index
\end_layout

\begin_layout Plain Layout

	max_subsequence=[]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	while k != -1 :            
\end_layout

\begin_layout Plain Layout

		max_subsequence.append(L[k])            
\end_layout

\begin_layout Plain Layout

		k = subsequence[k]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    max_subsequence.reverse()            
\end_layout

\begin_layout Plain Layout

	return max_subsequence
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Análise dos tempos de execução
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nesta seção apresentamos uma comparação dos tempos de execução obtidos para
 as diferentes implementações apresentadas para diferentes tamanhos de entrada:
\end_layout

\begin_layout Subsubsection*
Subsequências Contíguas
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="4">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tamanho da entrada
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Algoritmo cúbico
\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="left" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Algoritmo Quadrático
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Algoritmo linear
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(N^{3})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(N^{2})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(N)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{0}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13 segundos
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
154 milésimos
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25 milésimos
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 segundos
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
88 milésimos
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Tempos de execução
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Subsequências Não-Contíguas
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tamanho da entrada
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Algoritmo Quadrático
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(N^{2})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{0}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Tempos de execução
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Exercício Selecionado 3
\end_layout

\begin_layout Subsubsection*
Stingy SAT
\end_layout

\begin_layout Standard
Este exercício foi extraído do livro 
\emph on
Algorithms
\begin_inset CommandInset citation
LatexCommand cite
key "Dasgupta2006"

\end_inset

, 
\emph default
capítulo 6,STINGY SAT é o nome dado ao seguinte problema: Dado um conjunto
 de cláusulas (cada cláusula é uma disjunção de literais) e um inteiro ‘k’,
 encontre uma solução que satisfaça o conjunto de cláusulas com no máximo
 k variáveis iguais a true, se esta solução existir.
\end_layout

\begin_layout Subsubsection*
Discussão
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename sat.png
	scale 30

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Redução SAT-STINGY SAT
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
Implementação
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Subsection
Exercício Selecionado 2
\end_layout

\begin_layout Subsubsection
Enunciado
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
O Exercício a seguir foi extraído do livro 
\emph on
Algorithm Design
\emph default
 de 
\emph on
John Kleinberg
\emph default
 e de 
\emph on
Eva Tardos
\emph default
, capitulo 4, sendo o exercício de numero 7.
 Vamos expôr apenas um resumo do enunciado, com as principais informaçoes
 para resolução de tal exercício.
 Destaca-se aqui, que a escolha desse exercício foi pautada pelo interesse
 em enunciar e provar a eficiência de um algoritmo guloso.
\end_layout

\begin_layout Standard
Dado um problema, um algoritmo guloso tem como principal característica
 construir uma solução em pequenos passos, de modo a escolher uma ação a
 cada passo sob um determinado critério, com o objetivo de otimizar a solução
 final.
 Dessa forma, ao final da rotina, deve-se retornar como saída uma solução
 ótima.
 É possível identificar diferentes critérios para resolução de um problema,
 por intermédio de um algoritmo guloso, porém, não necessariamente, o critério
 escolhido nos leva à solução ótima.
 Dessa forma, após construir um algoritmo guloso, se faz necessário provar
 que a solução proposta por tal algoritmo é ótima, sendo esse o nosso objetivo
 com esse exercício.
\end_layout

\begin_layout Standard
O supercomputador exerce trabalhos diferentes que possuem tempo final 
\begin_inset Formula $P_{1},P_{2},...,P_{n}$
\end_inset

.
 Um trabalho exercido pelo supercomputador 
\begin_inset Formula $P_{i}$
\end_inset

 só se inicia quando outro 
\begin_inset Formula $P_{i-1}$
\end_inset

 termina.
 Após o trabalho do supercomputador, é necessário o trabalho de um PC para
 processamento dos dados.
 Os PCs possuem tempo final de trabalho da ordem de 
\begin_inset Formula $f_{1},f_{2},...,f_{n}$
\end_inset

.
 Pergunta-se: Qual a melhor forma de alocar os trabalhos dos supercomputadores
 e dos PCs de modo a minimizar o tempo de processamento do dado.
\end_layout

\begin_layout Subsubsection
Prova da Otimalidade
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A primeira etapa será analisar os jobs do supercomputador.
 Como já dito no enunciado, 
\begin_inset Formula $P_{i}$
\end_inset

 será o valor da duração dos jobs do supercomputador e 
\begin_inset Formula $F_{i}$
\end_inset

 o valor duração dos jobs dos PCs.
\end_layout

\begin_layout Standard
Uma vez que todos os jobs de um PC iniciam necessariamente após o job de
 um supercomputador, e como os jobs dos supercomputadores devem ser ordenados
 de modo que nao haja sobreposição entre seus valores, podemos inferir que
 a ordem dos supercomputadores é indiferente, pois dadas as hipóteses listadas,
 o que de fato irá interferir no tempo final dos jobs será a ordem dos trabalhos
 dos PCs.
\end_layout

\begin_layout Standard
Com efeito, nosso algoritmo A exposto em código python na próxima seção
 ordena a duração dos jobs feitos pelos PCs em ordem decrescente.
 Em resumo, nosso critério será escolher a cada passo o job de um PC de
 maior valor.
 Através desse algoritmo, vamos ser capazes de alocar os jobs dos supercomputado
res e dos PCs de modo a gastar o menor tempo possível nessa tarefa, como
 será provado a seguir:
\end_layout

\begin_layout Standard

\emph on
Passo Base: Seja k a iteraçãao no tempo, temos nesse passo k = 1.
\end_layout

\begin_layout Standard

\emph on
Seja 
\emph default

\begin_inset Formula $F_{i}^{*}$
\end_inset


\emph on
 o job de maior duração feito por um PC, supõe-se um algoritmo O que não
 posiciona o job 
\emph default

\begin_inset Formula $F_{i}^{*}$
\end_inset


\emph on
 na primeira posição, isto é, após o termino do job do primeiro supercomputador.
 Isso nos leva à conclusão de que o algoritmo O não ordena os trabalhos
 dos PCs em ordem decrescente dos valores de duração.
 Aqui, destaca-se o fato de que para um job de um PC começar o de um supercomput
ador deve terminar e, no passo base, apenas um job 
\begin_inset Formula $P_{1}$
\end_inset

 foi concluído por um supercomputador.
 Seja T o tempo gasto pelo algoritmo A implementado nesse artigo e seja
 T` o tempo gasto pelo algoritmo O, pode-se afirmar que:
\end_layout

\begin_layout Standard

\emph on
\begin_inset Formula 
\[
T=P_{1}+F_{i}^{*}<P_{-1}+F_{i}^{*}=T^{'}
\]

\end_inset

 
\end_layout

\begin_layout Standard

\emph on
Ao considerar 
\begin_inset Formula $P_{-1}$
\end_inset

como P não um, sabemos que tal job começará necessariamente após 
\begin_inset Formula $P_{1}$
\end_inset

.
 Ou seja, se 
\emph default

\begin_inset Formula $F_{i}^{*}$
\end_inset


\emph on
 for posicionado em outro lugar que não com 
\begin_inset Formula $P_{1}$
\end_inset

 por O, o algoritmo A termina em menor tempo.
 Por outro lado, se 
\emph default

\begin_inset Formula $F_{i}^{*}$
\end_inset

 é
\emph on
 posicionado com 
\begin_inset Formula $P_{1}$
\end_inset

 por O, como em A, temos que os dois fazem a mesma escolha ótima T.
 Assim o algoritmo A mantém a propriedade de "stays ahead"(nota de rodape)
 de algoritmos gulosos.
\end_layout

\begin_layout Standard

\emph on
Passo Indutivo: Aqui, considera-se que as iterações k =< n são válidas.
\end_layout

\begin_layout Standard

\emph on
A partir da hipótese indutiva podemos dizer que:
\end_layout

\begin_layout Standard

\emph on
\begin_inset Formula 
\[
T=P_{k+1}+F_{i-k}^{*}<P_{k+j}+F_{i-k}^{*}=T^{'},\; sendo\; j>1
\]

\end_inset


\end_layout

\begin_layout Standard

\emph on
Isso é válido pois 
\begin_inset Formula $P_{n+j}$
\end_inset

 necessariamente começa após 
\begin_inset Formula $P_{n+1}$
\end_inset

 o que faz do tempo em O ser maior do que em A.
 Se j = 1, então o algoritmo O possui tempo igual ao tempo de A, o que garante
 a propriedade de stays ahead.
 Dessa forma, pode-se concluir que nosso algoritmo é ótimo.
\end_layout

\begin_layout Subsubsection
Implementação
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Entrada: Uma lista de jobs representados por tuplas do tipo 
\begin_inset Formula $(p_{i},f_{i})$
\end_inset

 em que o primeiro elmento é o tempo que o supercomputador leva para processar
 o job e o segundo, é o tempo de execução em um PC.
\end_layout

\begin_layout Standard
Saída: Uma lista de jobs -representados por tuplas do tipo 
\begin_inset Formula $(p_{i},f_{i})$
\end_inset

- na ordem ótima em que devem ser executados para minimizar o tempo total
 de execução.
 
\end_layout

\begin_layout Standard
--Funcao auxiliar criada para selecionar elementos da tupla que serao comparados
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def compare(a, b):     
\end_layout

\begin_layout Plain Layout

	return a[1] >= b[1] 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Funcao merge que faz a operacao de sort ao concatenar o maior elemento #com
 os demais elementos da lista 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def merge(lista_rst, lista_nd):     
\end_layout

\begin_layout Plain Layout

	if len(lista_rst) is 0:         
\end_layout

\begin_layout Plain Layout

		return(lista_nd)     
\end_layout

\begin_layout Plain Layout

	elif len(lista_nd) is 0:         
\end_layout

\begin_layout Plain Layout

		return(lista_rst)     
\end_layout

\begin_layout Plain Layout

	else:         
\end_layout

\begin_layout Plain Layout

	#Modificacao para iterar entre tuplas e ordenar em ordem decrescente  
       	#dos valores dos jobs dos PCs         
\end_layout

\begin_layout Plain Layout

		if compare(lista_rst[0], lista_nd[0]):             
\end_layout

\begin_layout Plain Layout

			temp = [lista_rst[0]]
\end_layout

\begin_layout Plain Layout

			temp.extend(merge(lista_rst[1:],lista_nd))             
\end_layout

\begin_layout Plain Layout

			return(temp)         
\end_layout

\begin_layout Plain Layout

		else:             
\end_layout

\begin_layout Plain Layout

			temp = [lista_nd[0]]             
\end_layout

\begin_layout Plain Layout

			temp.extend(merge(lista_rst,lista_nd[1:]))             
\end_layout

\begin_layout Plain Layout

			return(temp)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def mergesort_inverse(lista):     
\end_layout

\begin_layout Plain Layout

	if len(lista) <= 1:         
\end_layout

\begin_layout Plain Layout

		return(lista)     
\end_layout

\begin_layout Plain Layout

	else:         
\end_layout

\begin_layout Plain Layout

		med = len(lista) // 2         
\end_layout

\begin_layout Plain Layout

		result=merge(mergesort_inverse(lista[:med]),mergesort_inverse(lista[med:]))
        
\end_layout

\begin_layout Plain Layout

		return(result)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
deve-se ordenar jobs de maneira decrescente nos tempos de trabalho dos PCs
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#jobs = [(24,5),(31,9),(57,22),(39,56),(5,1),(82,43)]
\end_layout

\begin_layout Plain Layout

def schedule(jobs):    
\end_layout

\begin_layout Plain Layout

	return(mergesort_inverse(jobs))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "bibliografia"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
