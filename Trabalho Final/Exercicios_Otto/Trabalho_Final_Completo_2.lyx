#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\begin_preamble
\renewcommand \thefigure{Figura~\@arabic\c@figure}
\def\fps@figure{tbp}
\def\ftype@figure{1}
\def\ext@figure{lof}
\def\fnum@figure{\thefigure}
\definecolor{green}{RGB}{0, 100, 0}
\definecolor{red4}{RGB}{139, 0, 0}
\definecolor{keywords}{RGB}{0,104,139}
\definecolor{gray}{RGB}{162, 181, 205}
\definecolor{Strings}{rgb}{0,0.63,0}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language brazilian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing onehalf
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3.5cm
\topmargin 3.5cm
\rightmargin 3.5cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "aboveskip={0.5cm},basicstyle={\small\ttfamily},breaklines=true,captionpos=b,commentstyle={\itshape\color{gray}},keywords={import,from,class,def,for,while,if,is,in,elif,else,not,and,or,print,break,continue,return,access,as,,del,except,exec,finally,global,lambda,pass,print,raise,try,assert},keywordstyle={\color{keywords}\bfseries},ndkeywords={len,range, None},ndkeywordstyle={\color{red4}\bfseries},stringstyle={\color{Strings}},tab=true,tabsize=3,xleftmargin={1cm},xrightmargin={1cm}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center

\size large
FUNDAÇÃO GETÚLIO VARGAS
\end_layout

\begin_layout Standard
\align center

\size large
ESCOLA DE MATEMÁTICA APLICADA
\end_layout

\begin_layout Standard
\align center

\size large
MESTRADO 2015.1
\end_layout

\begin_layout Standard
\align center

\size large
ESTRUTURA DE DADOS E SEUS ALGORITMOS
\end_layout

\begin_layout Standard
\align center

\size large
Prof Alexandre Rademaker
\end_layout

\begin_layout Standard
\begin_inset VSpace 3cm
\end_inset


\end_layout

\begin_layout Standard
\align center

\size large
Apresentação e discussão dos exercícios selecionados
\end_layout

\begin_layout Standard
\begin_inset VSpace 3cm
\end_inset


\end_layout

\begin_layout Standard
\align center
ALUNOS:
\end_layout

\begin_layout Standard
\align center
KIZZY TERRA
\end_layout

\begin_layout Standard
\align center
OTTO TAVARES
\end_layout

\begin_layout Standard
\begin_inset VSpace 3cm
\end_inset


\end_layout

\begin_layout Standard
\align center
RIO DE JANEIRO
\end_layout

\begin_layout Standard
\align center
JUNHO DE 2015
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Introdução
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Este relatório reúne comentários e implementações dos exercícios selecionados
 cujos enunciados foram previamente apresentados em sala de aula.
 O objetivo deste documento é, acima de tudo, apresentar as interessantes
 discussões que emergiram a medida que os exercícios foram sendo analisados
 e solucionados, ultrapassando a mera exposição da resposta final encontrada
 para cada questão escolhida.
 Cabe ressaltar que alguns dos exercícios selecionados foram utilizados
 apenas como ponto de partida para discussões mais enriquecedoras a fim
 de proporcionar maior aprendizado e possibilitando os conhecimentos adquiridos
 ao longo do curso fossem, de fato, colocados em prática.
\end_layout

\begin_layout Section
Exercícios selecionados: comentários e discussões
\end_layout

\begin_layout Subsection
Exercício Selecionado 1
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Este exercício foi extraído do livro 
\emph on
Algorithms 
\emph default
de
\emph on
 S.
 Dasgupta, C.
 H.
 Papadmitriou 
\emph default
e
\emph on
 U.V.
 Varzani, 
\emph default
capítulo 6, sendo o exercício 6.1.
 O enunciado deste exercício refere-se a um conhecido problema de programação
 dinâmica: subsequência de soma máxima.
 Este problema consiste de encontrar a subsequência de números com maior
 soma dentro de lista de números unidimensional dada.
 Este problema possui duas principais variações unidimensionais: na primeira,
 consideram-se apenas subsequências contíguas da lista de números; na segunda,
 por sua vez, as subsequências podem envolver números que não são contíguos.
 
\end_layout

\begin_layout Standard
O problema da subsequência contígua de soma máxima foi proposto pela primeira
 vez em 1977 por Ulf Grenander da 
\emph on
Brown University, 
\emph default
como um modelo simplificado do problema de estimativa de padrões por máxima
 verossimilhança em imagem digitalizadas.
 O problema original do estimador de máxima verossimilhança é na verdade
 um problema de subsequência de soma máxima bidimensional, mas foi proposto
 por Grenander em sua forma simplificada (unidimensional) visto que o problema
 bidimensional exigia mais tempo para ser resolvido.
 Uma solução de tempo linear para o problema unidimensional foi encontrada
 pouco tempo depois que o problema foi proposto por Jay Kadane da 
\emph on
Carnegie-Mellon University.[Bentley, 1984 ---]
\end_layout

\begin_layout Subsubsection
A primeira versão
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Subsubsection*
Problema: Subsequência contígua de soma máxima
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Entrada: Uma lista de números 
\begin_inset Formula $a_{1}$
\end_inset

, 
\begin_inset Formula $a_{2}$
\end_inset

, 
\begin_inset Formula $a_{3}$
\end_inset

, 
\begin_inset Formula $\ldots$
\end_inset

 , 
\begin_inset Formula $a_{n}$
\end_inset


\end_layout

\begin_layout Standard
Saída: A subsequência contígua de soma máxima (uma subsequência de tamanho
 zero possui soma zero)
\end_layout

\begin_layout Subsubsection*
Discussão
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A solução mais ingênua que se pode dar para esta questão consiste de um
 algoritmo força bruta que calcula todas as possíveis combinações de subsequênci
as, calcula a soma para cada uma delas e retorna a subsequência correspondente
 a maior soma encontrada.
 A seguir é apresentada a implementação desta abordagem ingênua em Python.
 
\end_layout

\begin_layout Standard
O método implementado possui três laços 
\emph on
for 
\emph default
encadeados e cada um deles irá iterar no máximo N vezes, em que N é o número
 de elemntos da lista de números dada como entrada, portanto a complexidade
 deste algoritmo é 
\begin_inset Formula $O(N^{3})$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout
\align left

def cubic(L):
\end_layout

\begin_layout Plain Layout

	sizeL = len(L)
\end_layout

\begin_layout Plain Layout

	if sizeL == 0:
\end_layout

\begin_layout Plain Layout

		return L
\end_layout

\begin_layout Plain Layout

	max_sum = L[0]
\end_layout

\begin_layout Plain Layout

	max_subsequence = L[:1]
\end_layout

\begin_layout Plain Layout

	for j in range(1, sizeL):
\end_layout

\begin_layout Plain Layout

		for i in range(j): 
\end_layout

\begin_layout Plain Layout

			current_sum = 0
\end_layout

\begin_layout Plain Layout

			for k in range(i,j):
\end_layout

\begin_layout Plain Layout

				current_sum += L[k]
\end_layout

\begin_layout Plain Layout

			if current_sum > max_sum:
\end_layout

\begin_layout Plain Layout

				max_sum = current_sum
\end_layout

\begin_layout Plain Layout

				max_subsequence = L[i:j]
\end_layout

\begin_layout Plain Layout

	return max_subsequence
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A partir da complexidade do algoritmo já é possível observar que esta solução
 é pouco eficiente, apenas para ilustrar, em um notebook comum, para uma
 entrada de tamanho 
\begin_inset Formula $N=1000$
\end_inset

 este método levou aproximadamente 13 segundos para terminar de executar
 e para 
\begin_inset Formula $N=10000$
\end_inset

 o tempo de execução foi X[ta faltando completar aqui] horas.
\end_layout

\begin_layout Standard
A solução cúbica apresentada é claramente ineficiente e por essa razão,
 basta pensar um pouco para identicar que podemos modificá-la facilmente
 e torná-la ligeiramente melhor.
 É possível tornar o algortimo anteriormente proposto mais eficiente apenas
 eliminando o laço 
\emph on
for 
\emph default
mais interno, de forma a obtermos a implementação a seguir:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def quadratic(L):
\end_layout

\begin_layout Plain Layout

	sizeL = len(L)
\end_layout

\begin_layout Plain Layout

	if sizeL == 0:
\end_layout

\begin_layout Plain Layout

		return L
\end_layout

\begin_layout Plain Layout

	max_sum = L[0]
\end_layout

\begin_layout Plain Layout

	max_subsequence = L[:1]
\end_layout

\begin_layout Plain Layout

	for j in range(sizeL):
\end_layout

\begin_layout Plain Layout

		current_sum = 0
\end_layout

\begin_layout Plain Layout

		for i in range(j, sizeL):
\end_layout

\begin_layout Plain Layout

			current_sum += L[i]
\end_layout

\begin_layout Plain Layout

			if current_sum > max_sum:
\end_layout

\begin_layout Plain Layout

				max_sum = current_sum
\end_layout

\begin_layout Plain Layout

				max_subsequence = L[i:j+1]
\end_layout

\begin_layout Plain Layout

	return max_subsequence
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Esta implementação possui dois laços
\emph on
 for
\emph default
 encadeados e cada um será executado N vezes, no pior caso, logo a complexidade
 do algoritmo apresentado é 
\begin_inset Formula $O(N^{2})$
\end_inset

.
 Para esta implementação o tempo de execução de uma entrada de tamanho 
\begin_inset Formula $N=1000$
\end_inset

 em um notebook com capacidade de processamento regular foi de 154 milésimos
 de segundo e para 
\begin_inset Formula $N=10000$
\end_inset

 o tempo de execução foi 6 segundos, aproximadamente.
\end_layout

\begin_layout Standard
Embora o algoritmo quadrático seja mais eficiente do que o algoritmo cúbico,
 é possível propor soluções ainda melhores.
 A seguir será discutida uma solução linear similiar à solução proposta
 por Kadane na ocasião em que o problema foi proposto.
\end_layout

\begin_layout Subsubsection*
A solução linear
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A idéia para esta implementação é utilizar a técnica de programação dinâmica,
 isto é, construir a solução de um problema através da solução de subproblemas
 associados.
 Neste contexto, a primcipal idéia é considerar que para cada elemento I
 da lista de números a solução procurada (subsequência contígua de soma
 máxima) é dada pela solução encontrada para o elemento anteiror I - 1(se
 existir) mais o atual elemento I, ou seja, 
\begin_inset Formula $S[I-1]\cup L[I]$
\end_inset

 ou a solução procurada é uma subsequência que começa no elemento I, nesse
 caso 
\begin_inset Formula $S[I]=\{L[I]\}$
\end_inset

.
 Para implementar esta idéia é necessário utilizar variáveis auxiliares
 para armazenar a melhor solução encontrada, bem como a solução para cada
 iteração.
 Assim, o método inicia-se através da inicialização das variáveis como segue:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

startSoFar = 0     
\end_layout

\begin_layout Plain Layout

startPrevious = 0     
\end_layout

\begin_layout Plain Layout

endSoFar = 0     
\end_layout

\begin_layout Plain Layout

maxSoFar = L[0]     
\end_layout

\begin_layout Plain Layout

maxPrevious = L[0]     
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A variável 
\emph on
startSoFar
\emph default
 armazena o índice do elemento que inicia a subsequência de maior soma,
 a variável 
\emph on
startPrevious
\emph default
 armazena o índice do elemento que inicia a subsequência de maior soma encontrad
a na iteração anterior; a variável endSoFar armazena o índice do elemento
 que encerra a subsequência de maior soma, a variável maxSoFar armazena
 o valor da subsoma máxima e a variável maxPrevious armazena o valor da
 subsoma máxima encontrada na iteração anterior.
\end_layout

\begin_layout Standard
Em seguida implementa-se um laço 
\emph on
for 
\emph default
para calcular a solução do problema para cada elemento I (em cada iteração
 calcula-se a resposta para o problema como se a lista de números terminasse
 no elemento I), para isso verifica-se qual subsequência possui maior soma:
 a subsequência composta por todos os elementos até I (
\begin_inset Formula $S[I-1]\cup L[I]$
\end_inset

 ) ou a subsequência que se inicia em I(
\begin_inset Formula $S[I]=\{L[I]\}$
\end_inset

).
 Uma vez encontrada a melhor solução para a iteração as variáveis auxiliares
 são devidamente atualizadas: caso a subsoma encotrada ao final de uma determina
da iteração (
\emph on
maxPrevious
\emph default
) seja maior que a subsoma máxima encontrada em todas as iterações anteriores
 (
\emph on
maxSoFar
\emph default
), então as variáveis 
\emph on
maxSoFar
\emph default
, 
\emph on
startSoFar
\emph default
 e 
\emph on
endSoFar
\emph default
 são modificadas.
\end_layout

\begin_layout Standard
\begin_inset VSpace 2.7cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if maxPrevious + L[i] >= L[i]:             
\end_layout

\begin_layout Plain Layout

	maxPrevious = maxPrevious + L[i]         
\end_layout

\begin_layout Plain Layout

else:            
\end_layout

\begin_layout Plain Layout

	startPrevious = i             
\end_layout

\begin_layout Plain Layout

	maxPrevious = L[i]         
\end_layout

\begin_layout Plain Layout

if maxPrevious >= maxSoFar:             
\end_layout

\begin_layout Plain Layout

	maxSoFar = maxPrevious             
\end_layout

\begin_layout Plain Layout

	endSoFar = i             
\end_layout

\begin_layout Plain Layout

	startSoFar = startPrevious     
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ao final de todas as iterações a subsequência de soma máxima é retornada.
 O método completo é apresentado a seguir:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def linear(L):
\end_layout

\begin_layout Plain Layout

	startSoFar = 0     
\end_layout

\begin_layout Plain Layout

	startPrevious = 0     
\end_layout

\begin_layout Plain Layout

	endSoFar = 0     
\end_layout

\begin_layout Plain Layout

	maxSoFar = L[0]     
\end_layout

\begin_layout Plain Layout

	maxPrevious = L[0] 
\end_layout

\begin_layout Plain Layout

	for i in range(1,len(L)):         
\end_layout

\begin_layout Plain Layout

		if maxPrevious + L[i] >= L[i]:             
\end_layout

\begin_layout Plain Layout

			maxPrevious = maxPrevious + L[i]         
\end_layout

\begin_layout Plain Layout

		else:            
\end_layout

\begin_layout Plain Layout

			startPrevious = i             
\end_layout

\begin_layout Plain Layout

			maxPrevious = L[i]         
\end_layout

\begin_layout Plain Layout

		if maxPrevious >= maxSoFar:             
\end_layout

\begin_layout Plain Layout

			maxSoFar = maxPrevious             
\end_layout

\begin_layout Plain Layout

			endSoFar = i             
\end_layout

\begin_layout Plain Layout

			startSoFar = startPrevious 
\end_layout

\begin_layout Plain Layout

	return L[startSoFar:endSoFar+1]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
No método apresentado o laço 
\emph on
for 
\emph default
é o único bloco da implementação que depende do tamanho da entrada e este
 laço irá executar N vezes, e para cada iteração irá executar um número
 constante de operações O(1), portanto a complexidade desta solução é 
\begin_inset Formula $O(N)$
\end_inset

.
 O tempo de execução deste método para uma entrada de tamanho N=1000 foi
 de 25 milésimos, para N=10000 foi de 88 milésimos.
\end_layout

\begin_layout Subsubsection
A segunda versão
\end_layout

\begin_layout Subsubsection*
Problema: Subsequência de soma máxima
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Entrada: Uma lista de números 
\begin_inset Formula $a_{1}$
\end_inset

, 
\begin_inset Formula $a_{2}$
\end_inset

, 
\begin_inset Formula $a_{3}$
\end_inset

, 
\begin_inset Formula $\ldots$
\end_inset

 , 
\begin_inset Formula $a_{n}$
\end_inset


\end_layout

\begin_layout Standard
Saída: A subsequência (não necessariamente contígua) de maior soma
\end_layout

\begin_layout Subsubsection*
Discussão
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Antes de se discutir uma implementação para esta outra versão do problema
 da subsequência de soma máxima, é conveniente que se discuta a razão pela
 qual as implementações apresentadas na seção anterior não funcionam para
 este caso em que os números que compõe a sequência podem ser não-adjacentes.
 Isto deve-se ao fato de que naquelas implementações em cada iteração considerav
a-se apenas a informação da solução encontrada na iteração correspondente
 ao elemento imediatamente anterior, desconsiderando-se, portanto, outras
 soluções calculadas em iterações anteriores.
 Entretanto, para que se possa encontrar a solução correta para este caso,
 é necessárioXXXXXXXXXXXXXX A seguir serão apresentadas duas diferentes
 soluções para aboradar o problema, neste caso em que a subsequência pode
 ser composta de números não-adjacentes: uma com complexidade de tempo quadrátic
a no tamanho da entrada e outra com complexidade de tempo linear.
 
\end_layout

\begin_layout Subsubsection
Uma breve análise do problema bidimensional
\end_layout

\begin_layout Standard
""""" Talvez eu tire
\end_layout

\begin_layout Subsection
Exercício Selecionado 2
\end_layout

\begin_layout Subsubsection
Enunciado
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
O Exercício a seguir foi extraído do livro 
\emph on
Algorithm Design
\emph default
 de 
\emph on
John Kleinberg
\emph default
 e de 
\emph on
Eva Tardos
\emph default
, capitulo 4, que aborda o tema de algoritmos gulosos, sendo o exercício
 de numero 7.
 Vamos expôr apenas um resumo do enunciado, com as principais informaçoes
 para resolução de tal exercício.
 Destaca-se aqui, que a escolha desse exercício foi pautada pelo interesse
 em enunciar e provar a eficiência de um algoritmo guloso.
\end_layout

\begin_layout Standard
Dado um problema, um algoritmo guloso tem como principal característica
 construir uma solução em pequenos passos, de modo a escolher uma ação a
 cada passo sob um determinado critério, com o objetivo de otimizar a solução
 final.
 Dessa forma, ao final da rotina, deve-se retornar como saída uma solução
 ótima.
 É possível identificar diferentes critérios para resolução de um problema,
 por intermédio de um algoritmo guloso, porém, não necessariamente, o critério
 escolhido nos leva à solução ótima.
 Dessa forma, após construir um algoritmo guloso, se faz necessário provar
 que a solução proposta por tal algoritmo é ótima, sendo esse o nosso objetivo
 com esse exercício.
\end_layout

\begin_layout Standard
O supercomputador exerce trabalhos diferentes que possuem tempo final 
\begin_inset Formula $P_{1},P_{2},...,P_{n}$
\end_inset

.
 Um trabalho exercido pelo supercomputador 
\begin_inset Formula $P_{i}$
\end_inset

 só se inicia quando outro 
\begin_inset Formula $P_{i-1}$
\end_inset

 termina.
 Após o trabalho do supercomputador, é necessário o trabalho de um PC para
 processamento dos dados.
 Os PCs possuem tempo final de trabalho da ordem de 
\begin_inset Formula $f_{1},f_{2},...,f_{n}$
\end_inset

.
 Pergunta-se: Qual a melhor forma de alocar os trabalhos dos supercomputadores
 e dos PCs de modo a minimizar o tempo de processamento do dado.
\end_layout

\begin_layout Subsubsection
Prova da Otimalidade
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A primeira etapa será analisar os jobs do supercomputador.
 Como já dito no enunciado, 
\begin_inset Formula $P_{i}$
\end_inset

 será o valor da duração dos jobs do supercomputador e 
\begin_inset Formula $F_{i}$
\end_inset

 o valor duração dos jobs dos PCs.
\end_layout

\begin_layout Standard
Uma vez que todos os jobs de um PC iniciam necessariamente após o job de
 um supercomputador, e como os jobs dos supercomputadores devem ser ordenados
 de modo que nao haja sobreposição entre seus valores, podemos inferir que
 a ordem dos supercomputadores é indiferente, pois dadas as hipóteses listadas,
 o que de fato irá interferir no tempo final dos jobs será a ordem dos trabalhos
 dos PCs.
\end_layout

\begin_layout Standard
Com efeito, nosso algoritmo A, exposto em código python na próxima seção,
 ordena a duração dos jobs feitos pelos PCs em ordem decrescente.
 Em resumo, nosso critério será escolher a cada passo o job de um PC de
 maior valor.
 Através desse algoritmo, vamos ser capazes de alocar os jobs dos supercomputado
res e dos PCs de modo a gastar o menor tempo possível nessa tarefa, como
 será provado a seguir:
\end_layout

\begin_layout Standard

\emph on
Passo Base: Seja k a iteração no tempo, temos nesse passo k = 1.
\end_layout

\begin_layout Standard

\emph on
Seja 
\emph default

\begin_inset Formula $F_{i}^{*}$
\end_inset


\emph on
 o job de maior duração feito por um PC, supõe-se um algoritmo O que não
 posiciona o job 
\emph default

\begin_inset Formula $F_{i}^{*}$
\end_inset


\emph on
 na primeira posição, isto é, após o termino do job do primeiro supercomputador.
 Isso nos leva à conclusão de que o algoritmo O não ordena os trabalhos
 dos PCs em ordem decrescente dos valores de duração.
 Aqui, destaca-se o fato de que para um job de um PC começar o de um supercomput
ador deve terminar e, no passo base, apenas um job 
\begin_inset Formula $P_{1}$
\end_inset

 foi concluído por um supercomputador.
 Seja T o tempo gasto pelo algoritmo A implementado nesse artigo e seja
 T` o tempo gasto pelo algoritmo O, pode-se afirmar que:
\end_layout

\begin_layout Standard

\emph on
\begin_inset Formula 
\[
T=P_{1}+F_{i}^{*}<P_{-1}+F_{i}^{*}=T^{'}
\]

\end_inset

 
\end_layout

\begin_layout Standard

\emph on
Ao considerar 
\begin_inset Formula $P_{-1}$
\end_inset

como P não um, sabemos que tal job começará necessariamente após 
\begin_inset Formula $P_{1}$
\end_inset

.
 Ou seja, se 
\emph default

\begin_inset Formula $F_{i}^{*}$
\end_inset


\emph on
 for posicionado em outro lugar que não com 
\begin_inset Formula $P_{1}$
\end_inset

 por O, o algoritmo A termina em menor tempo.
 Por outro lado, se 
\emph default

\begin_inset Formula $F_{i}^{*}$
\end_inset

 é
\emph on
 posicionado com 
\begin_inset Formula $P_{1}$
\end_inset

 por O, como em A, temos que os dois fazem a mesma escolha ótima T.
 Assim o algoritmo A mantém a propriedade de "stays ahead"
\begin_inset Foot
status open

\begin_layout Plain Layout
Método de demonstração, o qual compara-se as soluções parciais que o algoritmo
 guloso constrói com as soluções parciais propostas por um algoritmo suposto
 ótimo.
 O objetivo é mostrar que o algoritmo guloso possui soluções iguais ou melhores,
 do ponto de vista de otimalidade, frente ao algoritmo suposto ótimo.
\end_layout

\end_inset

 de algoritmos gulosos.
\end_layout

\begin_layout Standard

\emph on
Passo Indutivo: Aqui, considera-se que as iterações k =< n são válidas.
\end_layout

\begin_layout Standard

\emph on
A partir da hipótese indutiva podemos dizer que:
\end_layout

\begin_layout Standard

\emph on
\begin_inset Formula 
\[
T=P_{k+1}+F_{i-k}^{*}<P_{k+j}+F_{i-k}^{*}=T^{'},\;sendo\;j\geq1
\]

\end_inset


\end_layout

\begin_layout Standard

\emph on
Considera-se 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $F_{i-k}^{*}$
\end_inset


\family default
\series default
\shape default
\size default
\emph on
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang brazilian
 como o job de maior duração na iteração k.
 Esta desigualdade é válida pois 
\begin_inset Formula $P_{n+j}$
\end_inset

 necessariamente começa após 
\begin_inset Formula $P_{n+1}$
\end_inset

 o que faz do tempo em O ser maior do que em A.
 Se j = 1, então o algoritmo O possui tempo igual ao tempo de A, o que garante
 novamente a propriedade de stays ahead.
 Dessa forma, pode-se concluir que nosso algoritmo é ótimo.
\end_layout

\begin_layout Subsubsection
Implementação
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A entrada do problema é uma lista de jobs representados por tuplas do tipo
 
\begin_inset Formula $(p_{i},f_{i})$
\end_inset

 em que o primeiro elemento é o tempo que o supercomputador leva para processar
 o job e o segundo é o tempo de execução que PC escolhido leva para análise
 tais dados.
\end_layout

\begin_layout Standard
Já a saída é uma lista de jobs -representados por tuplas do tipo 
\begin_inset Formula $(p_{i},f_{i})$
\end_inset

- na ordem ótima em que devem ser executados para minimizar o tempo total
 de execução.
 Isto posto, vamos analisar as funções criadas para resolução do problema.
\end_layout

\begin_layout Standard
É importante destacar que estamos implementando um algoritmo guloso, que
 já teve sua otimalidade demonstrada na seção anterior.
 Após a prova de otimalidade do algoritmo, a implementação consiste em uma
 variação do mergesort, pois estamos interessados na ordem descrescente
 de elementos que serão expostos na lista de tuplas.
 
\end_layout

\begin_layout Standard
Para tornar mais claro o argumento, vamos expor um exemplo de como será
 o dado de input.
 A lista a seguir expõe tuplas com os valores de tempo tomado pelos supercomputa
dores para processamento dos dados na primeira casa e a segunda casa leva
 o tempo tomado pelos PCs para análise dos dados em questão.
 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

lista = [(24,5),(31,9),(57,22),(39,56),(5,1),(82,43)]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A primeira função analisada corresponde àquela responsável por comparar
 duas tuplas no caso base e é denominada de 
\emph on
compare
\emph default
.
 Ela toma os valores dos tempos do PC (i.e.
 segunda casa) como parâmetro.
 Essa função tem custo de complexidade O(1).
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def compare(a, b):     
\end_layout

\begin_layout Plain Layout

	return a[1] >= b[1] 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A segunda função analisada é a 
\emph on
merge
\emph default
 modificada.
 A função 
\emph on
merge
\emph default
, revisitada pelo problema, expõe como caso base o controle de quando umas
 das listas possui tamanho nulo, retornando a outra lista de input.
 Até aqui a estrutura do algoritmo é semelhante, mas a partir do caso base,
 o nossa função de comparação faz do argumento recursivo retornar os elementos
 em ordem inversa, o que nos proporciona ordenar os jobs dos PCs em ordem
 decrescente, como segue: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def merge(lista_rst, lista_nd):     
\end_layout

\begin_layout Plain Layout

	if len(lista_rst) is 0:         
\end_layout

\begin_layout Plain Layout

		return(lista_nd)     
\end_layout

\begin_layout Plain Layout

	elif len(lista_nd) is 0:         
\end_layout

\begin_layout Plain Layout

		return(lista_rst)     
\end_layout

\begin_layout Plain Layout

	else:         
\end_layout

\begin_layout Plain Layout

	#Modificacao para iterar entre tuplas e ordenar em ordem decrescente dos
 valores dos jobs dos PCs         
\end_layout

\begin_layout Plain Layout

		if compare(lista_rst[0], lista_nd[0]):             
\end_layout

\begin_layout Plain Layout

			temp = [lista_rst[0]]
\end_layout

\begin_layout Plain Layout

			temp.extend(merge(lista_rst[1:],lista_nd))             
\end_layout

\begin_layout Plain Layout

			return(temp)         
\end_layout

\begin_layout Plain Layout

		else:             
\end_layout

\begin_layout Plain Layout

			temp = [lista_nd[0]]             
\end_layout

\begin_layout Plain Layout

			temp.extend(merge(lista_rst,lista_nd[1:]))             
\end_layout

\begin_layout Plain Layout

			return(temp)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Por fim, a função 
\emph on
mergesort_inverse
\emph default
 é responsável por receber a lista exposta acima e chamar a função 
\emph on
merge
\emph default
 aplicada ao 
\emph on
mergesort_inverse 
\emph default
da metade das listas.
 Esse argumento possui complexidade da ordem de O(nlogn) e retorna os tempos
 dos jobs dos PCs em ordem decrescente.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def mergesort_inverse(lista):     
\end_layout

\begin_layout Plain Layout

	if len(lista) <= 1:         
\end_layout

\begin_layout Plain Layout

		return(lista)     
\end_layout

\begin_layout Plain Layout

	else:         
\end_layout

\begin_layout Plain Layout

		med = len(lista) // 2         
\end_layout

\begin_layout Plain Layout

		result=merge(mergesort_inverse(lista[:med]),mergesort_inverse(lista[med:]))
        
\end_layout

\begin_layout Plain Layout

		return(result)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Conclusão
\end_layout

\begin_layout Standard
Destaca-se que esse problema teve sua escolha aclamada por abordar conceitos
 de Algoritmos Gulosos e de Divisão e Conquista, sendo a prova de otimalidade
 fundamentada pelo primeiro e a implementação pelo segundo.
 Dado que devemos minimizar o tempo dos jobs dos computadores, possuímos
 uma função objetivo que deve ser minimizada e, para isso, utilizamos os
 conceitos de algoritmos gulosos, de modo a escolher um critério, que será
 utilizado por passo, minimizando o tempo de processamento em questão.
 Ao concluir a prova de otimalidade, é fácil ver que a implementação se
 resume ao ordenamento dos dados de input, o que nos leva à luz da implementação
 de um Mergesort modificado de custo O(nlogn) de complexidade.
 
\end_layout

\begin_layout Subsection
Exercício Selecionado 3
\end_layout

\begin_layout Subsubsection
Enunciado
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Esse exercício foi extraído do livro 
\emph on
Algorithm Design
\emph default
 de 
\emph on
John Kleinberg
\emph default
 e de 
\emph on
Eva Tardos, 
\emph default
capítulo 5, sendo o exercício de número 3 o selecionado.
 Segue um resumo do enunciado:
\end_layout

\begin_layout Standard
Supõe-se que esteja fazendo uma consultoria a um banco, que está preocupado
 em detectar possíveis fraudes, e esse banco surge com o seguinte problema:
\end_layout

\begin_layout Standard
O banco possui uma coleção de N cartões, os quais foram confiscados, pois
 o banco suspeita que tais cartões estejam sendo usados em uma fraude.
 Cada cartão de crédito é um pequeno pedaço de plástico, contendo uma tira
 magnética com um dado criptografado.
 Cada conta pode possuir uma série de cartões de crédito, e vamos dizer
 que dois cartões são equivalente se eles correspondem à mesma conta.
 É muito dificil ler o número criptografado, mas o banco possui uma tecnologia
 que faz o seguinte teste:
\end_layout

\begin_layout Standard
Toma dois cartões, faz algumas contas e determina se os cartões são equivalentes.
\end_layout

\begin_layout Standard
Isto posto, a pergunta é a seguinte: Entre a coleção de N cartões, existe
 um conjunto maior que N/2 cartões que acusarão equivalência no teste? Considera
-se a hipótese de a única operaç
\end_layout

\begin_layout Standard
ão possível que se possa fazer para terstar os cartões seja pegar dois deles,
 plugar na máquina, e dai verificar a equivalência..
 
\end_layout

\begin_layout Standard
Nossa abordagem no presente artigo será a de resolução do exercício proposto
 pelo livro, para posteriormente aplicarmos essa resolução a um problema
 real, evolvendo um dataset com dados de educação superior no Brasil.
\end_layout

\begin_layout Subsubsection
Abordagem Linear
\end_layout

\begin_layout Standard
Inspirado em um problema real, buscamos resolver o problema exposto no enunciado
 através de uma solução linear, tomando algumas hipóteses simplicaficadoras
 para facilitar a análise.
 O primeiro passo consiste na estruturação do dado de forma conveninente,
 para que a partir do dado estruturado sejamos capazes de capturar os valores
 que apresentam igualdade com custo de complexidade linear.
 Após a estruturação do dado vamos explicar como se deu a construção das
 funções responsáveis por coparação dos dados, contagem dos casos com igualdade,
 e da função mestre, responsável por chamar todas as demais e verificar
 sob determinado parâmetro se há fraude.
 Destaca-se que nossa solução usará o zero como parâmetro ao invés de metade
 da lista, pois somos capazes de retornar o número de fraudes.
 Assim caso esse número seja diferente de zero, a função retorna um valor
 lógico 
\emph on
True, 
\emph default
além de retornar 
\emph on
False
\emph default
 caso contrário.
 A pertinência do input parâmetro consiste na extensão do algoritmo para
 casos mais gerais comparados ao exercício em questão.
 Para resolver o exercício proposto basta-se truncar o parâmetro no valor
 zero e se interessar apenas no valor lógico.
 No entanto, em outras aplicações pode ser pertinente tolerar um certo nível
 maior do que zero de 
\begin_inset Quotes eld
\end_inset

fraudes
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Implementação
\end_layout

\begin_layout Standard
Com efeito, o algoritmo leva em consideração algumas hipóteses simplificadoras.
 Para que seja linear e retorne o valor desejado, os dados, aqui representando
 códigos, quando iguais, e em número par, devem estar justapostos em pares,
 não importando a posição de tais pares.
 Caso haja um número ímpar de determinado código, deve-se justapor o número
 par máximo de códigos em pares e o valor restante deve ser justaposto com
 outro valor que tenha sobrado de uma situação semelhante, isto é, de um
 conjunto de códigos iguais ímpares.
 Caso não haja esse outro valor, deve-se justapor o valor que tenha sobrado
 com a variável nula.
\end_layout

\begin_layout Standard
A seguir se expõe como é feita a construção da lista, atendendo as condições
 descritas acima.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

lst = [1201,1201,1308,1308,1201,1403,1308] 
\end_layout

\begin_layout Plain Layout

lst_pares = []
\end_layout

\begin_layout Plain Layout

pare = len(lst) + 1 
\end_layout

\begin_layout Plain Layout

teste_impar = len(lst) % 2 != 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if teste_impar:     
\end_layout

\begin_layout Plain Layout

pare = len(lst) 
\end_layout

\begin_layout Plain Layout

cont = 1 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

while cont != pare:     
\end_layout

\begin_layout Plain Layout

lst_pares.append((lst[cont - 1],lst[cont]))     
\end_layout

\begin_layout Plain Layout

cont += 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if teste_impar:     
\end_layout

\begin_layout Plain Layout

lst_pares.append((lst[len(lst) - 1], None)) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A lista construída para o exemplo ilustrado acima tem o seguinte formato:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[(1201, 1201), (1308, 1308), (1201, 1403), (1308, None)]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Após a construção da lista, vamos mostrar como se deu a construção da função
 responsável por comparar os valores dos códigos analisados.
 A função 
\emph on
compara, 
\emph default
quando chamada, toma dois valores e verifica sua igualdade.
 Caso haja igualdade ela retorna o valor lógico 
\emph on
True
\emph default
 e retorna 
\emph on
False 
\emph default
caso contrário.
 Essa função possui custo de complexidade da ordem O(1).
 Segue o código:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def compara(valor1, valor2):     
\end_layout

\begin_layout Plain Layout

if valor1 == valor2:         
\end_layout

\begin_layout Plain Layout

return(True)     
\end_layout

\begin_layout Plain Layout

else:         
\end_layout

\begin_layout Plain Layout

return(False)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Além da função compara, se faz necessário definir outras duas funções de
 teste.
 A primeira seria a função 
\emph on
testa_igual 
\emph default
e a segunda seria a 
\emph on
testa_dif.
 
\emph default
A construção dessas funções se mostrou necessária, pois dado que possuímos
 uma lista de tuplas, temos interesse em criar uma lista com tuplas que
 representem apenas pares iguais, ou que tenham um par entra um código e
 um valor nulo e, outra lista, que apresente apenas pares com valores diferentes
 entre si.
 Dai, de posse dessas funções, basta utilizarmos o argumento linear filter,
 que será explicado com mais calma a seguir, para que sejamos capazes de
 criar as listas citadas.
 É importante destacar que ambas função possuem custo de complexidade O(1).
 Seguem-nas:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def testa_igual(lista):     
\end_layout

\begin_layout Plain Layout

if lista[0] == lista[1]:         
\end_layout

\begin_layout Plain Layout

return(lista[0])     
\end_layout

\begin_layout Plain Layout

elif lista[0] is None:         
\end_layout

\begin_layout Plain Layout

return(lista[1])     
\end_layout

\begin_layout Plain Layout

elif lista[1] is None:         
\end_layout

\begin_layout Plain Layout

return(lista[0])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def testa_dif(lista):     
\end_layout

\begin_layout Plain Layout

if lista[0] != lista[1]:         
\end_layout

\begin_layout Plain Layout

return((lista[0],lista[1]))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nesse passo, vamos descrever a construção da função de maior importância
 da implementação em questão, a função 
\emph on
contagem
\emph default
.
 Será por intermédio dessa função que seremos capazes de contar os códigos
 que extrapolam o número permitido, e assim, retornarmos o número de fraudes.
 Dado que o input são as listas, já citadas, dos pares de valores iguais
 (restante) e a dos pares de valores distindos (deletado),
\begin_inset Foot
status open

\begin_layout Plain Layout
O nome restante se dá pelo fato de o argumento funcional que constrói tal
 lista, retornar apenas os valores restantes que atendem ao critério de
 igualdade seus valores, critério esse definido através da construção da
 função 
\emph on
testa_igual.

\emph default
 Enquanto o nome deletado recorre justamente do fato de que esses são os
 valores que não estão justpostos em igualdade sendo deletados da primeira
 lista.
\end_layout

\end_inset

o primeiro passo da função 
\emph on
contagem
\emph default
 decorre de tomar tais listas e desconstruí-las de modo a criar duas novas
 listas com os valores dos casos em que já se tem pares definidos (restante_list
a) ou um valor que tenha sobrado, para o caso de a lista ter tamanho ímpar,
 e a outra lista ser justamente os valores que não estavam justapostas aos
 seus pares (deletado_lista).
 A partir dai, toma-se cada valor da primeira lista citada(restante_lista)
 e busca-se na segunda lista citada (deletado_lista) por repetições.
 Caso uma repetição seja encontrada, conta-se uma fraude e deleta-se o valor
 encontrado da lista de busca (i.e.
 deletado_lista).
 Dessa forma, no primeiro passo tem-se complexidade O(n/2), no segundo O(n/4),
 e assim por diante, além de O(n-1) para realização dos testes, dando um
 total de no máximo O(2n) de complexidade, pro pior caso de se percorrer
 toda a lista duas vezes.
 Segue o código:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def contagem(restante, deletado):     
\end_layout

\begin_layout Plain Layout

repeticoes = 0     
\end_layout

\begin_layout Plain Layout

restante_lista = []     
\end_layout

\begin_layout Plain Layout

deletado_lista = []     
\end_layout

\begin_layout Plain Layout

#necessario transformas as listas que estavam em tuplas em apenas listas,
 para manter linearidade.
     
\end_layout

\begin_layout Plain Layout

for valor_tupla in restante:         
\end_layout

\begin_layout Plain Layout

	restante_lista.append(valor_tupla[0])     
\end_layout

\begin_layout Plain Layout

for valor_tupla in deletado:         
\end_layout

\begin_layout Plain Layout

	deletado_lista.extend([valor_tupla[0],valor_tupla[1]])     
\end_layout

\begin_layout Plain Layout

for valor in restante_lista:         
\end_layout

\begin_layout Plain Layout

	cont = 0         
\end_layout

\begin_layout Plain Layout

	if valor is None:             
\end_layout

\begin_layout Plain Layout

		next         
\end_layout

\begin_layout Plain Layout

	while cont != len(deletado_lista):             
\end_layout

\begin_layout Plain Layout

		if compara(valor,deletado_lista[cont]) is True:                 
\end_layout

\begin_layout Plain Layout

		repeticoes += 1                 
\end_layout

\begin_layout Plain Layout

		deletado_lista.remove(deletado_lista[cont])                 
\end_layout

\begin_layout Plain Layout

		cont -= 1             
\end_layout

\begin_layout Plain Layout

	cont += 1     
\end_layout

\begin_layout Plain Layout

return(repeticoes)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dai, a função 
\emph on
teste 
\emph default
é responsável por receber a lista de tuplas, criada no primeiro passo, e
 o parâmetro de comparação e a partir dai chamar as funções já explicadas
 de modo a encontrar a solução desejada, que retornar se há fraude, e o
 número de fraudes em questão.
 Através de um argumento funcional denominado filter, na linguagem python,
 toma-se a lista de input e utiliza-se o critério da função 
\emph on
testa_igual 
\emph default
para criar a função das tuplas de códigos iguais justapostos, que será a
 variável restante demandada pela função 
\emph on
contagem, 
\emph default
enquanto o mesmo argumento, toma a mesma lista, e utilza do critério da
 função 
\emph on
testa_dif, 
\emph default
para criar a lista das tuplas que não apresentam elementos iguais, lista
 que será utilizada pela funão contagem no input denominado deletado.
 A partir dai, a função contagem devolve o número de fraudes, caso haja,
 e assim a função 
\emph on
teste 
\emph default
compara com o parâmetro dado, retornando o argumento lógico 
\emph on
True, 
\emph default
caso o extrapole e o argumento 
\emph on
False,
\emph default
 caso contrário.
 Além disso a função retorna o número de 
\begin_inset Quotes eld
\end_inset

fraudes
\begin_inset Quotes erd
\end_inset

 encontradas.
\end_layout

\begin_layout Subsubsection
Conclusão
\end_layout

\begin_layout Standard
A função criada resolve o problema exposto pelo livro, além de apresentar
 um arcobouço geral, que porporciona a aplicação a outros tipos de análise.
 Como será visto a seguir, esse código será alterado, e talvez até simplificado,
 para resolução de um problema real, urgido durante a análise de um dataset.
\end_layout

\begin_layout Subsubsection
Dataset
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Surgiu o desafio de analisar um dataset que apresenta dados de docentes
 brasileiros em atividade em todos os programas de matemática registrados
 na CAPES.
 O desafio consiste em analisar quantos docentes que pesquisam e lecionam
 no mesmo centro que se titularam.
 Essa pergunta é pertinente pois existe uma recomendação da CAPES de que
 a proporção de professores que se titularam e são pesquisadores de um dado
 programa não seja maior que dois terços do quadro.
 Dessa forma, acionamos uma base de dados que nos apresenta as instituições
 as quais os docentes se titularam, e os centros que os mesmos trabalharam
 entre 2004 e 2012.
 Nosso desafio foi comparar os casos, verificar a igualdade entre eles e
 reportar se o numero de docentes nos programas de matemática no Brasil
 violam a regra.
 Lançamos mão de analisar instituicão por instituição por fugir do escopo
 da análise, isto é, da contextualização entre o exercicio proposto pelo
 livro e o problema real que nos propusemos a solucionar.
\end_layout

\begin_layout Standard
Um dos desafios da base está no fato de que as strings que correspondem
 às instituições que os docentes se titularam não estão expostas da mesma
 forma que as strings dos centros que os docentes compõem nos anos da análise.
 Assim, se fez necessário um tratamento das strings e a criação de uma função
 responsável por comparações que ao invés de levar um argumento lógico como
 balizador, levou em consideração a função de Levenshtein para verificar
 a proximidade das strings.
 No entanto, comparada à abordagem linear exposta acima, o fato de o dataset
 apresentar as respectivas instituições em que os professores atuam nos
 anos de análise já casadas com as instituições de titulação facilita a
 análise.
 Dito de outra forma, não existem pares desencontrados, ou valores ímpares,
 pois cada linha corresponde a um docente diferente e busca-se encontrar
 o número de semelhanças sobre um determinado critério.
 Com isso, a análise do dataset, teve como desafio a aplicação do caso abstrato
 ao caso real, por intermédio do relaxamento de algumas hipóteses lançadas
 na abordagem linar acima.
 Segue um recorte do dataset para melhor expor a natureza do problema:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /Users/ottotavares/Desktop/Captura de Tela 2015-06-22 às 19.43.57.png
	scale 35

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Recorte do Dataset
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Implementação
\end_layout

\begin_layout Standard
Isto posto, buscamos uma versão linear do algoritmo de resolução da questão
 proposta no livro.
 Pois somos capazes de criar uma lista de tuplas
\begin_inset Foot
status open

\begin_layout Plain Layout
Estrutura de dado que estabelece os dados em uma ordem finita definida.
\end_layout

\end_inset

 que farão uma relação entre a instituição que o docente atua e a instituição
 a qual ele se tituolou.
 Uma vez, que essa lista de tuplas é criada, somos capazes de passar por
 cada tupla, comparando em tempo linear, a igualdade entre as strings.
 Como já dito acima, essa comparação é feita por intermedio do algoritmo
 de Levenshtein.
 A teoria da distância de Levenshtein entre duas strings, diz respeito ao
 número de operações necessárias para transformar uma string em outra.
 Em nossa análise, tomamos como razoável uma distância de Leveinshtein de
 até dois.
 Segue o algoritmo:
\end_layout

\begin_layout Standard
A primeira parte diz respeito à importação das bibliotecas necessárias para
 análise.
 A 
\emph on
xlrd
\emph default
 é utilizada para importar os dados de uma planilha em excel, enquanto a
 biblioteca 
\emph on
re
\emph default
 é responsável por tratar as soluções de tratamento de strings via expressões
 regulares, enquanto a 
\emph on
Levenshtein 
\emph default
diz respeito à distância homonima descrita acima.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#O problema consiste na comparacao de strings a fim de descobrir qual a
 proporcao de professores 
\end_layout

\begin_layout Plain Layout

#Bibliotecas necessarias para importar e tratar o dataset que sera utilizado
 para analise 
\end_layout

\begin_layout Plain Layout

import xlrd 
\end_layout

\begin_layout Plain Layout

import re 
\end_layout

\begin_layout Plain Layout

import Levenshtein 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Deixamos a segunda parte da análise para descrever como estruturamos o dado.
 Como já descrito, buscamos as construção de uma lista de tuplas, justapondo
 as instituições que os docentes trabalham e qual eles se titularam respectivame
nte, de modo que a comparação de custo O(1) seja repetida n vezes, o que
 nos traz um custo linear para análise de toda base em questão.
 Assim, segue o exemplo:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#Exemplo meramente ilustrativo.
 
\end_layout

\begin_layout Plain Layout

lst = [("UFRJ","UERJ"), ("EMAP","EBAPE"), ("PUC Rio","PUC-MG"), ("UFF","FGV"),
 ("EBEF","EPGE"), ("UFRRJ","UFMG")]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Se faz necessário mostrar como limpamos os dados na terceira parte da análise.
 Em primeiro lugar importamos os dados de uma planilha em excel
\begin_inset Foot
status open

\begin_layout Plain Layout
A base de dados é confidencial.
 Faz parte de um projeto de pesquisa junto à EBAPE sobre métodos de avaliação
 da qualidade da educação Superior no Brasil.
\end_layout

\end_inset

, posteriormente necessitamos de expressões regulares para limpar as strings
 das instituições as quais os docentes se titularam pois essa parte do dado
 veio em formatação não usual.
 Por fim, transformamos todas as strings em maiusculas e construimos a lista
 de tuplas como exposto no exemplo acima.
 A descrição corresponde ao seguinte código:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#Importando e Limpando os dados 
\end_layout

\begin_layout Plain Layout

matematica_wb = xlrd.open_workbook("Matematica.xlsx", encoding_override =
 "utf8" ) 
\end_layout

\begin_layout Plain Layout

matematica_ws = matematica_wb.sheet_by_index(0) 
\end_layout

\begin_layout Plain Layout

instituicao = matematica_ws.col(4)  
\end_layout

\begin_layout Plain Layout

titulacao = matematica_ws.col(52) 
\end_layout

\begin_layout Plain Layout

titulacao_IES = []  
\end_layout

\begin_layout Plain Layout

cont = 0 
\end_layout

\begin_layout Plain Layout

for valor in titulacao:     
\end_layout

\begin_layout Plain Layout

valor_split = re.split("/",str(valor))     
\end_layout

\begin_layout Plain Layout

titulacao_IES.append((str(instituicao[cont]).upper(),valor_split[0].upper()))
     
\end_layout

\begin_layout Plain Layout

cont += 1
\end_layout

\begin_layout Plain Layout

#Iniciamos no indice 1, pois não nos interessamos no titulo.
 
\end_layout

\begin_layout Plain Layout

lst_tit_ies = titulacao_IES[1:]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A partir de agora, serão expostas as funções necessárias para verificar
 a semelhança entre as strings, realizar a contagem entre elas, e por fim
 verificar o número de casos de igualdade.
 A primeira função a ser abordade será a de comparações, que nesse caso
 será chamada de 
\emph on
teste_igual
\emph default
.

\emph on
 
\emph default
A função toma dois valores, compara a distância de Levenshtein entre eles
 e retorna o número um caso esse nível de distância seja abaixo de 2 e retorna
 o número zero caso contrário.
 Repara-se que a função 
\emph on
teste_igual
\emph default
 é uma variação da função 
\emph on
compara
\emph default
 explicada na implementação da abordagem linear.
 A alteração se faz necessária, pois estamos interessados em contar o casos
 que consideramos próximos, assim, de forma recursiva vamos chamar tal função
 para comparar e retornar tais valores que proporcionarão a capacidade de
 contagem.
 Repara-se que a complexidade dessa função é de O(1), pois toma dois valores
 e os compara através de um argumento lógico.
 Segue o código da função em questão.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#Utizamos indices na variavel valor, pois valor é uma tupla com duas casas.
 Dessa forma, o indices 0 e 1 correspondem a primeira e segunda classe respectiv
amente.
\end_layout

\begin_layout Plain Layout

def testa_igual(valor):     
\end_layout

\begin_layout Plain Layout

distancia_str = Levenshtein.distance(valor[0],valor[1])     
\end_layout

\begin_layout Plain Layout

if distancia_str <= 2:         
\end_layout

\begin_layout Plain Layout

return(1)     
\end_layout

\begin_layout Plain Layout

else:         
\end_layout

\begin_layout Plain Layout

return(0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Uma vez que a função 
\emph on
teste_igual
\emph default
 está definida podemos descrever a função 
\emph on
contagem
\emph default
.
 A função contagem toma uma lista de tuplas, e chama de forma recursiva
 suas metades de forma a otimizar a contagem do número e valores iguais
 entre instituições de trabalho e de titulação.
 Assim, o passo base consiste em comparar através da função 
\emph on
teste_igual 
\emph default
a igualdade das tuplas e contando os valores de contagem de metade da lista
 e os somando ao final de cada chamada.
 Dessa forma, o algoritmo retorna exatamente o número de casos em que a
 distância de Levenshtein das strings é menor ou igual a dois para todas
 os docentes nos anos de análise.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#Funcao que fara a contagem de casos de igualdade, isto e, casos em que
 os professores se titularam #e trabalham na mesma instituicao def contagem(list
a):     
\end_layout

\begin_layout Plain Layout

if len(lista) is 0:         
\end_layout

\begin_layout Plain Layout

return(0)     
\end_layout

\begin_layout Plain Layout

if len(lista) is 1:         
\end_layout

\begin_layout Plain Layout

return(testa_igual(lista[0]))     
\end_layout

\begin_layout Plain Layout

else:         
\end_layout

\begin_layout Plain Layout

med =len(lista)//2         
\end_layout

\begin_layout Plain Layout

return(contagem(lista[:med]) + contagem(lista[med:]))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Por fim, expomos a função responsãvel por receber a lista com os dados e
 chamar as funções já explicadas anteriormente, para que com os outputs
 das funções já explicadas, ela possa fazer a comparação entre o tamanho
 de casos de igualdade o parâmetro de anãlise.
 Como já citado, buscamos comparar a incidência de casos em que há igualdade
 de docentes com dois terços no número de docentes no pais.
 Assim, o nosso parametro será o valor correspondente a dois terços do número
 de observações totais.
 Caso seja maior, retornamos o lógico 
\emph on
True, 
\emph default
responsável por designar que mais de dois terços dos professores brasileiros
 se titularam na mesma insituição que trabalham.
 Caso a função contagem não extrapole o parametro dado como input, o retorno
 será o lógico 
\emph on
False
\emph default
.
 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# Função criada para responder a seguinte pergunta: Qual a proporcao de
 professores nos programas de Matematica do Brasil 
\end_layout

\begin_layout Plain Layout

#que se titularam e pesquisam no mesmo programa? 
\end_layout

\begin_layout Plain Layout

def verifica(universidades,parametro):     
\end_layout

\begin_layout Plain Layout

if contagem(universidades) > parametro:
\end_layout

\begin_layout Plain Layout

return(True,contagem(universidades))     
\end_layout

\begin_layout Plain Layout

else:         
\end_layout

\begin_layout Plain Layout

return(False,contagem(universidades))
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Conclusão
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Em resumo, busca-se através desse algortimo enfrentar um desafio real de
 análise de dados de educação superior no Brasil.
 A resolução em tempo linear do exercício proposto, já explicado acima,
 serviu de inspiração para criação desse código, que nos levou a inferir
 que 2105 docentes se titularam e trabalham no mesmo centro.
 Destaca-se que a análise é uma aproximação que pode estar levando em consideraç
ão repetições ou deixando de tomar casos de interesse, uma vez que as strings
 não estão expostas no mesmo formato e o dado está em painel.
 Apesar dos desafios, foi construído um código em tempo linear O(n), que
 retornou o lógico 
\emph on
False, 
\emph default
pois a base tem tamanho de 9322 observações.
\end_layout

\end_body
\end_document
